{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Documentation","text":"<ul> <li>Build<ul> <li>Build on Linux - installation manual of sc-machine on Linux-based systems</li> <li>Build on OSX - installation manual of sc-machine on OSX-based systems</li> <li>CMake Flags - description of CMake flags using to configure sc-machine</li> <li>Configuration File - description of a configuration file of sc-machine</li> </ul> </li> <li>API<ul> <li>C++ API - documentation of C++ API provided by sc-machine<ul> <li>C++ Core API - documentation of C++ core API for creating, retrieving and erasing sc-elements in sc-memory</li> <li>C++ Extended API: - documentation of C++ extended API for manipulating with system identifiers of sc-elements and sc-templates<ul> <li>System identifier C++ API - documentation of C++ extended API for manipulating with system identifiers of sc-elements</li> <li>ScTemplate C++ API - documentation of C++ extended API for creating and retrieving graphs (it is very useful when you want to work big sc-constructions)</li> </ul> </li> <li>C++ Agents API - documentation of C++ Agents API for creating sc-agents</li> </ul> </li> <li>Python API - documentation of Python API provided by py-sc-client<ul> <li>Python Core API - documentation of Python core API for creating, retrieving and erasing sc-elements and sc-events in sc-memory</li> <li>Python Extended API - documentation of Python extended API for manipulating with large graphs</li> </ul> </li> <li>TypeScript API - documentation of TypeScript API provided by ts-sc-client<ul> <li>TypeScript Core API - documentation of TypeScript core API for creating, retrieving and erasing sc-elements and sc-events in sc-memory</li> </ul> </li> <li>Sc-element types - detailed description of supported element types</li> <li>SCs-code - documentation on SCs Language with examples</li> </ul> </li> <li>Utils<ul> <li>Agents - detailed description of common sc-agents</li> </ul> </li> <li>Tools<ul> <li>Knowledge Base builder - description of options of sc-builder for knowledge base sources</li> <li>Knowledge Base repo file - description of configuration of knowledge base sources</li> <li>Websocket Server - description of options of sc-server for communication with sc-memory through network</li> <li>Sc-machine Runner - description of options of sc-machine runner</li> <li>Meta Programming - documentation of meta programming language</li> </ul> </li> <li>Development<ul> <li>Contributing Guide - guide for those who wants to make contribution into sc-machine</li> <li>Codestyle Guide - guide for those who wants to write code for sc-machine</li> <li>Dev Container - guide for those who wants to develop sc-machine via docker</li> </ul> </li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Block events mode for sc-memory context</li> <li>Opportunity to set permissions for set of users</li> <li>Guests identification</li> <li>Create guest users during creating sc-memory context</li> <li>Get user address for sc-server session and sc-memory context</li> <li>Docker entrypoint run to launch binary <code>sc-machine</code> in docker</li> <li>Script <code>run_sc_machine.sh</code> to launch binary <code>sc-machine</code></li> <li>Binary <code>sc-machine</code> instead of binary <code>sc-server</code> that loads extension sc-server</li> <li>Generalized build_cxx_project.sh</li> <li>Collect user permissions during sc-memory initialize</li> <li>Throw exceptions in get values methods of iterators if sc-element is not accessed</li> <li>Callback to get and collect sc-links by its contents from fs-memory</li> <li>Local user permissions for actions within sc-structures</li> <li>List in sc-element for input arcs from sc-structures</li> <li>Provide sc-arc types for sc-event callbacks</li> <li>User permissions for handling permissions for actions in sc-memory</li> <li>Global user permissions for actions in sc-memory</li> <li>ScType::LinkConstClass and ScType::LinkVarClass</li> <li>User authentication checks</li> <li>Denote sc-machine with sc-element <code>myself</code></li> <li>Provide users for sc-memory, sc-events and sc-agents</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Build codegen target first</li> <li>Up minimum required cmake version to 3.11.0</li> <li>Configure SC_BIN_PATH from scripts</li> <li>Allows assigns sc-link to its system identifier</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Private and public dependencies between cmake targets</li> <li>Use reenterable strtok</li> <li>Resolve sc.g-links with the same system identifier</li> </ul>"},{"location":"changelog/#deprecated","title":"Deprecated","text":"<ul> <li>Binary <code>sc-server</code>, script <code>run_sc_server.sh</code> and docker entrypoint command serve</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>GetDecompositionAgent</li> <li>Config option <code>sync_actions</code> in <code>[sc-server]</code> deprecated in 0.9.0</li> <li>Sc-links lists translation from C API to C++ API</li> </ul>"},{"location":"changelog/#090-unlock-22012024","title":"[0.9.0-Unlock] - 22.01.2024","text":""},{"location":"changelog/#breaking-changes","title":"Breaking changes","text":"<ul> <li>All methods in C++ API for managing sc-memory throws exceptions if passed params are not valid or memory state is not valid</li> <li>All methods in C API for managing sc-memory returns error codes if passed params are not valid or memory state is not valid</li> <li>Removed deprecated sc-utils in 0.6.0, 0.7.0 and 0.8.0</li> <li>Removed deprecated make_all.sh</li> </ul>"},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Config option <code>limit_max_threads_by_max_physical_cores</code> in <code>[sc-memory]</code> to limit max threads by max physical threads</li> <li>Config options <code>dump_memory</code> and <code>dump_memory_statistics</code> in <code>[sc-memory]</code> for enabling sc-memory dumps</li> <li>Full md docs for sc-memory API on C++ with examples</li> <li>ScTemplate replacement presence check using varAddr</li> <li>Iterator5 AAAAF</li> <li>Divide params errors handling and memory state handling</li> <li>Provide errors and exceptions information into C and C++ sc-memory API</li> <li>Support for gwf &lt;0.4.0</li> <li>Monitors for processes and thread synchronization</li> <li>Monitors tables for sc-addresses monitors and sc-event monitors</li> <li>Distribution of sc-segments by active processes and threads</li> <li>Internal sc-storage sc-segment-built-in lists for not engaged and freed sc-elements</li> <li>Clarify events managers for sc-storage: pick out subscription and emission managers</li> <li>Clarify context manager for sc-memory</li> <li>Common secured interface for sc-memory</li> <li>GetDecompositionAgent</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Optimize and move sc-memory dumps from sc-server to sc-memory</li> <li>Refactor all code by .clang-format 18.0.0</li> <li>Replace hyphens by underscores in files</li> <li>Replace underscores by hyphens in folders</li> <li>Update codestyle guide</li> <li>Update contributing guide</li> <li>Update .clang-format to 18.0.0</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Separate setups for sc-server and sc-builder from main.cpp and test</li> <li>Script scg.min.js styles handling for sc.g-element types of KBE &gt;0.4.0</li> <li>Sc.g-elements images in docs</li> <li>Support recursive curl braces in SCs-code level 2</li> <li>Support semantic sc-types for sc-node in SCs-code level 1</li> <li>Support sc-links for SCs-code level 1</li> <li>HelperBuildTemplate with params that have varAddr replacements</li> <li>Warnings for GNU compilers</li> <li>Warnings in sc-machine about deprecated methods</li> <li>Behavior of the agent_erase_elements on not his action classes</li> <li>Deleting existing and translated .scs sources with the same name</li> <li>Parse contours identifiers by gwf2scs-translator</li> <li>Symmetric sc-edges search</li> <li>sc-machine crashes when trying to view a picture in sc-web (311)</li> <li>No tests for ScMemory::Initialize(sc_memory_params) with different parameters (216)</li> <li>Too big number in websocket request crusher sc-server (309)</li> <li>Handle crush errors (63)</li> <li>Usage of invalid addresses after rerun failed sc-server (79)</li> <li>Invalid addrs crushes sc-iterator methods usages (66)</li> <li>All deadlocks and segfaults in sc-storage, sc-events and fs-memory (111)</li> <li>Processes and thread starvation</li> <li>Active waiting during sc-events deletion</li> <li>List items semicolons for sc.s-contours</li> <li>Internal sentences after sc.s-contour assignment</li> <li>Success of finishing the action is marked first and only then that it was finished</li> <li>Finish agent wait time</li> </ul>"},{"location":"changelog/#deprecated_1","title":"Deprecated","text":"<ul> <li>Config option <code>sync_actions</code> in <code>[sc-server]</code>, add option <code>parallel_actions</code> instead of</li> <li>Config option <code>update_period</code> in <code>[sc-memory]</code>, add option <code>dump_memory_statistics_period</code> instead of</li> <li>Config option <code>save_period</code> in <code>[sc-memory]</code>, add option <code>dump_memory_period</code> instead of</li> <li>Method <code>getLinkContent</code> in sc-utils </li> </ul>"},{"location":"changelog/#removed_1","title":"Removed","text":"<ul> <li><code>sc::ResolveRelationTuple</code> and <code>sc::SetRelationValue</code></li> <li>Deprecated sc-utils in 0.6.0, 0.7.0 and 0.8.0</li> <li>Deprecated make_all.sh</li> <li>Runtime asserts usage in sc-storage</li> <li>Atomic operations usage in sc-storage</li> <li>Locks usage in sc-storage</li> </ul>"},{"location":"changelog/#080-fusion-24092023","title":"[0.8.0-Fusion] - 24.09.2023","text":""},{"location":"changelog/#breaking-changes_1","title":"Breaking changes","text":"<ul> <li>Now we use C++17 instead of C++14</li> <li>We support compatibility with old memory binaries</li> </ul>"},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Add and get addresses by variable addresses in ScTemplateParams API</li> <li>Check sc-types in sc-memory API sc-elements creation methods</li> <li>Ability do not search for sc-links by substrings globally, passing config param <code>search_by_substring</code></li> <li>Ability do not search for sc-links by strings locally, passing param in SetLinkContent <code>is_searchable</code></li> <li>Generalize all scripts for applied projects</li> <li>Script <code>build_sc_machine.sh</code> with arguments <code>-f</code> <code>-t</code> and <code>-r</code> instead of <code>make_all.sh</code></li> <li>View kb fragment in scn if it is keyword</li> <li>Tests for repo-path parser and sources collector in <code>sc-builder</code></li> <li>Support for deprecated memory binaries build in 0.7.0 version</li> <li>Synchronize processes that works with file memory and sc-dictionary</li> <li>Get replacements in template result by variable addresses</li> <li>Divide strings file into more small files with fixed size by requested configs <code>max_strings_channels</code> and <code>max_strings_channel_size</code></li> <li>Configuration of docker-compose.yml using .env file</li> <li>Script <code>run_tests.sh</code></li> <li>Full tests for file memory API</li> <li>Intersect/unite search sc-links by strings and substrings in file memory</li> <li>Search strings and sc-link hashes by terms in file memory</li> <li>File memory on file system, save strings in file system disks</li> <li>Configure events and agents threads in sc-memory, passing config param <code>max_events_and_agents_threads</code></li> <li>Loop-ranged API method for sc-template search (78)</li> <li>Full tests for sc-template API</li> <li>Sc-template cycle preventing search</li> <li>Sc-template equal triples search</li> <li>Sc-template search API to get and use constructions step by step</li> <li>Sc-template search API to custom filter constructions with step by step search</li> <li>Sc-template search API with request commands (continue search, stop search and error during search)</li> <li>Cover all sc-template search and gen API with tests</li> <li>Order triples by type and dependencies with other triples</li> <li>Count input/output edges in elements during edges adding</li> <li>Order triples by input/output edges count for triple items</li> <li>Determined sc-template depth-first search</li> <li>Sc-template safe API without exceptions handling</li> <li>Extend create elements by SCs in <code>sc-server</code> with outputStructure field</li> <li>Write docs for system identifier set/get/find/resolve sc-memory API</li> <li>Extend set/get/find/resolve sc-memory API with out system identifier fiver parameters</li> <li>Insert sc-keynodes in global knowledge base during sc-memory initiation</li> <li>Save sc-memory by period in sc-server, passing config param <code>save_period</code> in seconds</li> <li>Dump statistics by period in sc-server, passing config param <code>update_period</code> in seconds</li> <li>Agent for erasing sc-elements not belonging to the global structure <code>init_memory_generated_structure</code></li> <li>Transfer init memory generated structure to modules initialization, passing config params <code>init_memory_generated_upload</code> and <code>init_memory_generated_structure</code></li> <li>Possibility to skip keys defined in .ini config file in ScConfig</li> <li>Pre-commit code style checks for C++ and Python</li> <li>Add reversed edges according to standart</li> <li>Sc-links classes <code>![]!</code> in SCs</li> <li>Insert sc-keynodes and their system identifiers in global knowledge base during sc-memory initiation</li> <li>Extend create elements by SCs in <code>sc-server</code> with outputStructure field</li> <li>Write docs for system identifier set/get/find/resolve sc-memory API</li> <li>Extend set/get/find/resolve sc-memory API with outer system identifier fiver parameters</li> <li>CI for documentation build</li> <li>Add output structure builder feature to config</li> <li>Add validation of system identifier</li> <li>Append generated elements by <code>SCs-helper</code> into requested output structure</li> <li>Oriented sets representation () in SCs <li>Build docs in SCn format separately from <code>ostis-web-platform</code></li>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Replace asserts in sc-memory API by exceptions throwing</li> <li>Refactor sc-server logs</li> <li>Decrease wait time for sc-element referencing in iterators</li> <li>Call gwf-translator in sc-builder</li> <li>Move repo path parser from Python to C++ in sc-builder</li> <li>Unite ScTemplateGenResult and ScTemplateSearchResultItem into ScTemplateResultItem</li> <li>Remove list to array translations in C API for file memory</li> <li>Upload text and binary files in realtime by get API</li> <li>Remove string lengths recount in file memory</li> <li>Optimize int to string translation in file memory</li> <li>Use iterators instead of sc-template in <code>getNextFromSet</code> util</li> <li>Generalized <code>docker_entrypoint.sh</code>, this script can be used by external projects now</li> <li>Now in tests all agents works in single thread</li> <li>Replace asserts in sc-template search and gen API by exceptions throwing</li> <li><code>ScsLoader::loadScsFile</code> return bool instead void</li> <li>Update garbage deletion agent logic, add check if element belongs to init memory structure</li> <li>Make scsi pre-processor migrations script</li> <li>Move to C++17</li> <li>Remove 1 minute assert in <code>ScWait</code></li> <li>Add language parameter for sc2scs-json-translator to get elements identifiers</li> <li>Append to sc2scs-json elements main/system identifiers</li> <li>Replace row strings by nlohmann-json in sc2scs-json-translator</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Check OS type in <code>install_dependencies.sh</code></li> <li>Check apt command for Linux OS in <code>install_deps_ubuntu.sh</code></li> <li>Create sc-links with ScType::Link type in Debug mode</li> <li>Change memory statistics fields types from sc_uint32 to sc_uint64</li> <li>Return empty sc_addr if not found by identifier in <code>sc-helper</code></li> <li>Build kb script doesn't ignore whitespace (239)</li> <li>Docker entrypoint throws integer expression expected (267)</li> <li>KB directory coping to prepare gwf and scsi sources </li> <li>Tests for template build and gen with params</li> <li>Aliases checking in build by scs</li> <li>Not use system identifiers of vars in sc-template-build</li> <li>Sc-template search by empty template (65)</li> <li>Segfaults in test sc-client</li> <li>Creating sc-keynodes without defining type. Now they will be created with const node type.</li> <li>Converting to string params from configs</li> <li>Fix hashes size in fs-storage (45)</li> <li>GetLinkContent skip whitespaces in strings</li> <li>No inserting system identifiers of keynodes to output structure (223)</li> <li><code>SCs-helper</code> doesn't return generated identifier links (207)</li> <li>No json string message parsing in <code>sc-server</code> (WebSocket request dumps sc-machine) (190)</li> <li>SCs-file dumps kb-builder by WebSocket (189)</li> <li><code>SCs-parser</code> create structure twice</li> <li><code>SCs-parser</code> doesn't unite all generated elements into structure (205)</li> <li>Link deletion (193)</li> <li>Add curl to installation script</li> <li>Fix memory clear parameter reading from .ini config file</li> <li>Merging identifiers in sc-dictionary (192)</li> <li>Dependence order in var template search triples (186)</li> </ul>"},{"location":"changelog/#removed_2","title":"Removed","text":"<ul> <li>Windows files and cmake dependencies</li> <li>Prepare kb step and <code>prepare_kb.py</code></li> <li>Rocksdb file memory</li> <li>Garbage deletion agent</li> </ul>"},{"location":"changelog/#070-rebirth-12102022","title":"[0.7.0-Rebirth] - 12.10.2022","text":""},{"location":"changelog/#breaking-changes_2","title":"Breaking changes","text":"<ul> <li>Binaries are built in the <code>bin</code> folder located near the CMake build tree. This will affect any project using sc-machine as a CMake subproject.</li> <li>Add <code>;</code> after <code>SC_LOG_INFO</code>, <code>SC_LOG_DEBUG</code>, <code>SC_LOG_WARNING</code> and <code>SC_LOG_ERROR</code> calls in projects that use sc-machine.</li> <li>Add <code>;</code> after <code>SC_ASSERT</code> calls in projects that use sc-machine.</li> <li>Remind that all binary content are stored in sc-fs-storage as base64 string.</li> <li>sctp-server was removed, move to sc-server usage.</li> <li>sc-machine doesn't support ubuntu versions lower than 20.04.</li> </ul>"},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Implement sc-link content removing from sc-storage</li> <li>Add command to find links contents by content substring into sc-server</li> <li>Implement find links contents by content substring into sc-server</li> <li>CI for docker build and run</li> <li>CI for ubuntu-22.04 and latest macOS</li> <li>Add ScExec class to execute system commands</li> <li>Test for utils for work with actions and their results</li> <li>Handle and save sc-server subcommands errors</li> <li>Add sc-server healthcheck</li> <li>Add tests for sc-search agents in sc-kpm</li> <li>Write sc-machine idea into readme</li> <li>Add create elements by scs-helper through sc-server</li> <li>Add CI workflow for sanitizers</li> <li>Add find links by substring in sc-server</li> <li>Initial development container support</li> <li>You can now run sc-machine in Docker</li> <li>Unite configuration for sc-server and sc-builder</li> <li>Write docs in scn-latex for sc-server</li> <li>Implement sc-memory configurator</li> <li>Implement sc-options for sc-server and sc-builder usages</li> <li>Implement sc-server on C++</li> <li>Add string API for set and get link content</li> <li>Add opportunity to search sc-links in <code>sc-dictionary</code> by content substr</li> <li>Excludes for files and folders in repo.path</li> <li>Automatic usage of ccache to speed up builds</li> <li>Add CI for <code>rocksdb</code> and <code>sc-dictionary</code></li> <li>Implement <code>sc-dictionary</code>. Add opportunity to switch <code>rocksdb</code> and <code>sc-dictionary</code></li> <li>Wrap and separate allocating, assertion, notification and atomic lock free procedures</li> <li>Add tests module for sc-agents-utils</li> <li>Add opportunity to configure sc-machine version from CMakeLists.txt</li> <li>Add scripts to build kb, run sctp-server and run sc-server</li> <li>New flag options for build_kb</li> <li>Add default python modules paths to python initialization</li> <li>United config file</li> </ul>"},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>Fix sc-server json casts to strings</li> <li>Check sc-server run in tests</li> <li>Flag --tests for sc-server to run and quick stop it</li> <li>Fix glib casts on ubuntu-20.04 and macOS</li> <li>Store binary content as base64 string</li> <li>Update action utils to use the new logic for waiting for action results</li> <li>Fix logic of waiting for action results</li> <li>Entrypoint of Docker image is now easier to work with</li> <li>Update commit badges</li> <li>Up codecov target from 40% to 75%</li> <li>Up codecov level from 62% to 78%</li> <li>Separate ci workflow: check pr-commit, codestyle and tests</li> <li>Revamped README.md</li> <li>Unify sc-builder and sc-server config and params usage</li> <li>Change sc-machine config file structure</li> <li>Fix gwf2scs-translator. Add opportunity to parse russian identifiers</li> <li>Simplify main CMakeLists.txt</li> <li>Add tools macros for main CMakeLists.txt</li> <li>Separate dependencies specifying from main CMakeLists.txt</li> <li>Correct typos</li> <li>Fix warnings in sc-memory modules</li> <li>Fix scs-grammar. Add opportunity to specificate a structure into this structure itself</li> </ul>"},{"location":"changelog/#removed_3","title":"Removed","text":"<ul> <li>Remove find by substring logic from sc-dictionary</li> <li>Remove legacy gwf-translator for 0.3.0 gwf sources from sc-builder</li> <li>Remove legacy glib-based tests</li> <li>Remove boost usage for options parsing in sc-server and sc-builder</li> <li>Unlink boost-python-lib from sc-machine</li> <li>Remove mkdocs for sc-server</li> <li>Remove sc-python-interpreter support</li> <li>Remove sc-python-module support</li> <li>Remove python sc-server</li> <li>Move logic rule utils and keynodes to ostis-inference</li> <li>Remove sctp-server</li> <li>Remove scp-interpreter</li> </ul>"},{"location":"changelog/#061-27042022","title":"[0.6.1] - 27.04.2022","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Search by template with params in C++ API</li> <li>Sanitizers</li> <li>Benchmarks</li> <li>Clang code formatting</li> <li>Common utils for C++ API</li> </ul>"},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>Migrate test system to <code>gtest</code></li> <li>Update macOS install_deps script</li> <li>Multithreaded build process used by default</li> <li>Move changelog to Keep a Changelog format</li> </ul>"},{"location":"changelog/#removed_4","title":"Removed","text":"<ul> <li>Moved React web interface in a separate new repository.</li> <li>Remove optional search triples support</li> </ul>"},{"location":"changelog/#v060","title":"v0.6.0","text":"<ul> <li> <p>Build system:</p> </li> <li> <p>Add support of OSX platform</p> </li> <li>Fix compilation with <code>clang</code></li> <li>Disable <code>SCP</code> and <code>SCTP</code> compilation by default</li> <li>Support of C++14</li> <li>Use Ubuntu 18.04 on Travis CI</li> <li> <p>Upgrade <code>libclang</code> to version 7</p> </li> <li> <p>Tools:</p> </li> <li> <p>Support custom extensions loading in <code>sc-builder</code></p> </li> <li>Add <code>sc-server</code> application to run claen <code>sc-memory</code> with extensions</li> <li>Refactored code generation tool</li> <li> <p>Refactored knowledge base tool</p> </li> <li> <p>Core:</p> </li> <li> <p>Support list of enabled extensions</p> </li> <li>Support all possible combinations of <code>sc_iterator3</code></li> <li>Support variable <code>sc-links</code></li> <li>Fix bug with repo directory write attributes</li> <li>Fix issue with extension loading on windows</li> <li>Fix issue with empty content of <code>sc-link</code></li> <li> <p>Refactored file memory to use rocksdb</p> </li> <li> <p>C++:</p> </li> <li> <p>Implement optional search triples support</p> </li> <li>Fix random crash of unittest</li> <li>Improve test system</li> <li>Replace <code>antlr3</code> with <code>antlr4</code> for <code>SCs-text</code> parsing</li> <li>Support of <code>SCs-text</code> aliases</li> <li>Support of 5 and 6 levels of <code>SCs-text</code></li> <li>Refactored test system</li> <li>Refactored API of <code>ScLink</code> and <code>ScStream</code></li> <li> <p>Add generation of structure from <code>SCs-text</code></p> </li> <li> <p>Python:</p> </li> <li> <p>Refactored test system</p> </li> <li>Support SCs-templates in WebSocket protocol</li> <li>Add support of template building from <code>SCs-code</code> string</li> <li>Add <code>Aliases</code> method to <code>ScTemplateSearchResult</code> and <code>ScTemplateGenResult</code></li> <li>Fix issue with float/double values support</li> <li>Add support of logs inside python modules</li> <li> <p>Support <code>ActionAgent</code> states</p> </li> <li> <p>KPM:</p> </li> <li> <p>web:</p> <ul> <li>Implement <code>http</code> module to access memory via Web interface</li> <li>Implement web browser interface to access <code>sc-memory</code></li> </ul> </li> <li> <p>Remove of <code>sc-merge</code> module</p> </li> <li> <p>Documentation:</p> </li> <li>Improve <code>SCs-code</code> documentation. Add levels <code>5</code> and <code>6</code></li> </ul>"},{"location":"changelog/#v050","title":"v0.5.0","text":"<ul> <li> <p>Build system:</p> </li> <li> <p>Add Visual Studio 2017 support</p> </li> <li> <p>Core:</p> </li> <li> <p>Fix bug with repository save (case when it output directory doesn't exist)</p> </li> <li> <p>C++:</p> </li> <li> <p>Fix bugs in python GIL work</p> </li> <li>Fix python threading</li> <li>Fix problem with twicely pass of edge in template search</li> <li>Fix problem with stack overflow on large template search</li> <li>Fix some python wrapping functions</li> <li>Improve <code>ScType</code> class</li> <li>Add types support in SCs-parser</li> <li>Add keynode cache</li> <li>Add <code>ScTemplate</code> build from SCs-text</li> <li> <p>Add support of pending events. Now events emit after whole template generated</p> </li> <li> <p>Python:</p> </li> <li> <p>Add <code>ScAgent</code> class</p> </li> <li>Improve custom main cycle in <code>ScModule</code></li> <li>Improve python testing</li> <li> <p>Implement <code>ScHelper</code> class</p> </li> <li> <p>Tools:</p> </li> <li> <p>Fix error handling in sc-builder</p> </li> <li> <p>Fix <code>show-filenames</code> parameter processing in sc-builder</p> </li> <li> <p>Documentation</p> </li> <li>Update documentation theme</li> <li>Improve python library documentation</li> <li>Support <code>SCs-syntax</code> highlight in documentation</li> </ul>"},{"location":"changelog/#v041","title":"v0.4.1","text":"<ul> <li>Add <code>ScSet</code> and <code>ScRelationSet</code> in python common library</li> <li>Add <code>ScPythonService</code> into C++ (allow to implement threaded python services)</li> <li>Add <code>GetType</code> and <code>AsBinary</code> functions into Python for a link content</li> <li>Add colors to python output</li> <li>Add signal handler to handle <code>Ctrl + C</code></li> <li>Fix bug with python modules search path initialization</li> <li>Fix bug with python threading</li> <li>Fix bug with builder run</li> <li>Fix bug with <code>ScLock</code></li> <li>Fix bug with Python interpreter shutdown</li> <li>Fix bug with <code>int8_t</code> type support in python bindings</li> <li>Fix bug with template generation, when pass parameter to triple with type that has no constancy flag</li> <li>Fix errors catch during collect python modules</li> <li>Refactoring of C++ Python bridge</li> </ul>"},{"location":"changelog/#v040","title":"v0.4.0","text":"<ul> <li>Add events support in Python scripts</li> <li>Improve Python scripts run</li> <li>Add common libraries for a Python</li> <li>Fix memory leaks in core</li> <li>Improve test logging</li> <li>Improve work with memory buffers</li> <li>Cleanup API</li> <li>Add support of python 3 code</li> <li>Add <code>ScLockScope</code> class</li> <li>Implement multithreaded python script run</li> <li>Pass <code>cpp_bridge</code> into python script</li> <li>Extract <code>ScWaitEvent</code> as a separated class from <code>ScWait</code></li> <li>Some fixes in template search</li> <li>Make log thread safe</li> <li>Implement <code>ScLink</code> wrapper class</li> <li>Add <code>ScBase64</code> encode/decode functions</li> <li>Add common templates generation (see <code>sc_common_templ.hpp</code>)</li> </ul>"},{"location":"changelog/#v031","title":"v0.3.1","text":"<ul> <li>Fix templates search error (problems was with triples search order)</li> <li>Implement logging for load extension module problems</li> <li>Remove <code>nl</code>, <code>iot</code> modules from kpm, because they are project specific (moved to a separate repo)</li> <li>Add <code>ForEach</code> function into template search result</li> <li>Add <code>ForEachIter</code> functions into <code>ScMemoryContext</code></li> <li>Add <code>ScSet</code> class</li> <li>Add support of http requests</li> </ul>"},{"location":"changelog/#v030","title":"v0.3.0","text":"<ul> <li>Implement search for elements, that has no constancy flag in a type</li> <li>Fix template search error (#251)</li> <li>Fix problem with <code>SC_ASSERT</code> compilation in release mode (#249)</li> <li>Implement SCs-text parser (levels 1 - 4)</li> <li>Agent <code>AApiAiParseUserTextAgent</code> can run commands</li> <li>Implement common function to work with commands in knowledge base</li> <li>Add support of keynode types in codegenerator. Now you can specify type of keynode that would be used to create it: <code>ForceCreate(ScType::Node...)</code></li> <li>Rename module funcitons from <code>initialize</code>, <code>shutdown</code>, <code>load_priority</code> to <code>sc_module_initialize</code>, <code>sc_module_shutdown</code>, <code>sc_module_load_priority</code></li> <li>Update code to codestyle. Most functions was renamed from <code>functionName</code> to <code>FunctionName</code>. Iterator <code>value</code> function replaced with <code>Get</code>.</li> <li>Implement support of result codes for action agents</li> <li>Improve unit test system</li> <li>Add MkDocs documentation generator support</li> <li>Add <code>clang-format</code> config</li> <li>Add codestyle document</li> <li>Add documentation for <code>C++</code> API</li> <li>Implement multithreaded emit of sc-events</li> <li>Implement ref counter for sc-elements</li> <li>Cover whole functionality of <code>C++</code> API by unit tests</li> <li>Implement <code>C++</code> API</li> </ul>"},{"location":"docker/","title":"Installation with Docker","text":""},{"location":"docker/#using-sc-machine-inside-docker","title":"Using sc-machine inside Docker","text":"<p>All our releases are automatically uploaded to Docker Hub, so to start using our latest release it's enough to have Docker installed and configured (please note that Docker from <code>snap</code> and Debian's/Ubuntu's repo are known to be broken, install using the official guide).</p>"},{"location":"docker/#launch","title":"Launch","text":"<pre><code>docker compose run --rm machine build #build KB (see below for details)\ndocker compose up #launch server\n</code></pre> <p>Generally you would want to use a KB source folder alongside sc-machine. To do that, create a \"kb\" folder in the root of the project and place the KB sources in it. After that build it using the command described above (or enable autorebuild as shown below).</p> <p>Note: By default we expect you to place a repo.path file inside the <code>./kb</code> folder, but in case you don't have one you can configure to build the folder itself by modifying the <code>.env</code> file:</p> <pre><code>+KB_PATH=\"/kb\"\n</code></pre> <p>If you want to auto-rebuild the knowledge base on sc-server restart, you can also configure this behavior in the <code>.env</code> file:</p> <pre><code>+REBUILD_KB=1\n</code></pre>"},{"location":"docker/#docker_entrypointsh","title":"docker_entrypoint.sh","text":"<p>Our Docker entrypoint script has two commands: <code>build</code> and <code>serve</code>. The former is used to build or update knowledge base, and the latter is used to launch <code>sc-server</code>. You can use it in your own projects that use sc-server as the entrypoint. Don't forget to configure custom binary and knowledge base paths. Consult with the <code>docker-entrypoint.sh --help</code> for the full list of available flags.</p>"},{"location":"docker/#rebuild-image","title":"Rebuild image","text":"<p>In case you want to run your own, changed version of <code>sc-machine</code> or you made some contributions that require changes to the image, use our <code>Dockerfile</code> to build a new version of the image. To rebuild the image, launch <code>docker build . -t ostis/sc-machine</code> in the root folder of this project. You'll be able to launch it using <code>docker compose up</code> afterwards.</p>"},{"location":"license/","title":"License","text":"<p>Unless otherwise indicated, Source Code is licensed under MIT license.</p> <p>Copyright (c) 2010-2024 OSTIS</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"thirdparty/","title":"Thirdparty","text":""},{"location":"thirdparty/#code-generator","title":"Code generator","text":"<p>Based on refactored code from: CPP-Reflection</p>"},{"location":"thirdparty/#sc-memory","title":"Sc-memory","text":"<ul> <li>JSON for Modern C++</li> <li>Antlr 4</li> <li>libclang</li> <li>Websocketcpp</li> </ul>"},{"location":"build/cmake_flags/","title":"CMake flags","text":""},{"location":"build/cmake_flags/#build-cache","title":"Build cache:","text":"<p>This project uses ccache automatically if it's available in the system. To disable this, use flag <code>-DAUTO_CCACHE=OFF</code></p>"},{"location":"build/cmake_flags/#building-tests","title":"Building tests:","text":"<pre><code>cmake -B build -DSC_BUILD_TESTS=ON -DSC_AUTO_TEST=ON\ncmake --build build -j$(nproc)\n</code></pre> <p>Additionally you can use <code>-DSC_BUILD_BENCH=ON</code> flag to build performance tests</p>"},{"location":"build/cmake_flags/#building-with-sanitizers","title":"Building with sanitizers","text":"<p>Use <code>cmake</code> with <code>-DSC_USE_SANITIZER=memory</code> or <code>-DSC_USE_SANITIZER=address</code> option to run build with memory or address sanitizer.  Note: sanitizers are only supported by <code>clang</code> compiler </p>"},{"location":"build/cmake_flags/#example","title":"Example:","text":"<pre><code>cmake -B build -DSC_USE_SANITIZER=memory -DCMAKE_CXX_COMPILER=clang++ -DCMAKE_C_COMPILER=clang\ncmake --build build\n</code></pre>"},{"location":"build/cmake_flags/#code-formatting-with-clangformat","title":"Code formatting with CLangFormat:","text":"<p>To check code with CLangFormat run: <pre><code>cmake -B build -DSC_CLANG_FORMAT_CODE=ON\ncmake --build build --target clangformat_check\n</code></pre></p> <p>or <pre><code>./scripts/clang/check_formatting.sh\n</code></pre></p> <p>To format code with CLangFormat run: <pre><code>cmake -B build -DSC_CLANG_FORMAT_CODE=ON\ncmake --build build --target clangformat\n</code></pre></p> <p>or <pre><code>./scripts/clang/format_code.sh\n</code></pre></p>"},{"location":"build/config/","title":"Configuration file","text":""},{"location":"build/config/#config-file-example","title":"Config file example","text":"<p><pre><code>[sc-memory]\n# Maximum number of segments. By default, it is 1000.\n# Remember, that one sc-segment size is 3932144 bytes. 1000 segments size is 4 GB.\nmax_loaded_segments = 1000\n\n# If it is equal to `true` then sc-memory use minimum between physical cores number and `max_events_and_agents_threads`.\nlimit_max_threads_by_max_physical_cores = true\n# Maximum number of threads that can be used in events and agents handler. By default, it is 32 if \n`limit_max_threads_by_max_physical_cores` is `true` or otherwise it is core number of device processor.\nmax_events_and_agents_threads = 32\n\n# Period (in seconds) to save sc-memory statistics. By default, it is 3600.\n# !!! It is deprecated option in sc-machine 0.9.0.\nsave_period = 3600 \n# It is equal to `save_period`. By default, it is 3600.\ndump_memory_period = 3600\n# Boolean indicating to enable sc-memory dump.\ndump_memory = true\n# Period (in seconds) to update sc-memory statistics. By default, it is 1800.\n# !!! It is deprecated option in sc-machine 0.9.0.\nupdate_period = 1800\n# It is equal to `update_period`. By default, it is 1800.\ndump_memory_statistics_period = 1800\n# Boolean indicating to enable sc-memory statistics dump.\ndump_memory_statistics = true\n\n# Path to compiled knowledge base folder (kb.bin should be inside this folder). By default, it is empty.\nrepo_path = /path/to/kb.bin\n# Path to sc-memory shared library extensions.\nextensions_path = /path/to/sc-machine/bin/extensions\n\n# Sc-memory log type. It can be `File` or `Console`.\nlog_type = File\n# Sc-memory log file.\nlog_file = /path/to/sc-machine/log/sc-server.log\n# Sc-memory log level. # It can be `Debug`, `Info`, `Warning` or `Error` also.\nlog_level = Info\n\n# Boolean indicating to upload all sc-element into one common sc-structure with system identifier `result_structure`.\ninit_memory_generated_upload = false\ninit_memory_generated_structure = result_structure\n\n# Maximum number of channels to split file memory into sections. By default, it is 1000.\nmax_strings_channels = 1000\n# Maximum file memory section size. By default, it is 100000.\nmax_strings_channel_size = 100000\n# Maximum size of strings that can be found by substring. By default, it is 1000.\nmax_searchable_string_size = 1000\n# Separators used to divide strings into tokens to find this strings by its tokens substrings. By default, it is \" _\".\n# If search by substring isn't needed, set this value to \"\" to increase maximum performance for strings linking and searching.\nterm_separators = \" _\" \n# If search by substring isn't needed, set this value to \"false\" to increase maximum performance for strings linking.\nsearch_by_substring = true\n\n[sc-server]\n# Sc-server socket data.\nhost = 127.0.0.1\nport = 8090\n\n# Sc-server mode to call parallely all input actions. By default, it is true.\nparallel_actions = true\n\n# Sc-server log type. It can be `File` or `Console`.\nlog_type = File\n# Sc-server log file.\nlog_file = /path/to/sc-machine/log/sc-server.log\n# Sc-server log level. # It can be `Debug`, `Info`, `Warning` or `Error` also.\nlog_level = Info\n\n[sc-builder]\n# Path with kb sources for building into sc-memory.\ninput_path = kb\n\n# File to dump sc-builder errors.\nlog_file = /path/to/sc-machine/log/sc_builder.log\n</code></pre> Note: If you use relative paths they will be resolved based on config file location.</p>"},{"location":"build/linux_build/","title":"Build on Linux","text":"<p>This instruction is intended to be used on Debian-based distros. For other distros, skip Install dependencies section and make sure you install all the required packages manually.</p>"},{"location":"build/linux_build/#clone","title":"Clone","text":"<pre><code>git clone https://github.com/ostis-ai/sc-machine.git --recursive\ncd sc-machine\n</code></pre>"},{"location":"build/linux_build/#install-dependencies","title":"Install dependencies","text":"<pre><code>./scripts/install_deps_ubuntu.sh --dev\n</code></pre>"},{"location":"build/linux_build/#build","title":"Build","text":"<pre><code>cmake -B build -DCMAKE_BUILD_TYPE=Release # use Debug for debug build\ncmake --build build -j$(nproc)\n</code></pre> <p>Alternatively, you can use a script: <pre><code>./scripts/build_sc_machine.sh -r #You can also pass -h to get help menu\n</code></pre></p> <p>Note: by default the binary outputs are saved in the <code>bin</code> folder, it is located at the same level as CMake build tree (the <code>build</code> folder). If you've generated the build tree in a location different from the root folder of the project, you may need to change further commands in the tutorial to accommodate for changed <code>bin</code> folder location.</p>"},{"location":"build/osx_build/","title":"Build on OSX","text":""},{"location":"build/osx_build/#clone","title":"Clone","text":"<pre><code>git clone https://github.com/ostis-ai/sc-machine.git --recursive\ncd sc-machine\n</code></pre>"},{"location":"build/osx_build/#install-dependencies","title":"Install dependencies","text":"<p>Note: you will need Homebrew installed and configured on your Mac.</p> <pre><code>./scripts/install_deps_macOS.sh\n</code></pre>"},{"location":"build/osx_build/#build","title":"Build","text":"<pre><code>cmake -B build -DCMAKE_BUILD_TYPE=Release # use Debug for debug build\ncmake --build build -j$(nproc)\n</code></pre> <p>Alternatively, you can use a script: <pre><code>./scripts/build_sc_machine.sh -r #You can also pass -h to get help menu\n</code></pre></p> <p>Note: by default the binary outputs are saved in the <code>bin</code> folder, it is located at the same level as CMake build tree (the <code>build</code> folder). If you've generated the build tree in a location different from the root folder of the project, you may need to change further commands in the tutorial to accommodate for changed <code>bin</code> folder location.</p>"},{"location":"dev/codestyle/","title":"Codestyle Guide","text":"<p>In general, Google's coding standard is used, and we strongly  encourage to read it.</p>"},{"location":"dev/codestyle/#code-style-guide","title":"Code Style Guide","text":"<p>All code should conform to C++17 standard. Here's a summary of the key rules specified in the configuration:</p>"},{"location":"dev/codestyle/#includes","title":"Includes","text":"<ul> <li>We use <code>.cpp</code> and <code>.hpp</code> files, not <code>.cc</code> and <code>.h</code> (<code>.c</code> and <code>.h</code> are used for C code), in UTF-8 encoding.</li> <li>File names are lowercase with underscores, like <code>sc_memory.cpp</code>.</li> <li>Directory names are lowercase with hyphen, like <code>sc-memory/</code>.</li> <li>We use <code>#pragma once</code> instead of the <code>#define</code> Guard in header files.</li> <li>Include categories are specified with priorities. There are two main categories: external libraries and internal  libraries. External libraries have the highest priority.</li> <li>Includes are sorted and grouped by directory, there should be newlines between different directories.</li> <li>Order of directories in includes: <code>current_dir/current_file.hpp</code>, other includes from the same dir, includes from other dirs sorted by name.</li> </ul> <pre><code>#include \"../test.hpp\"\n\n#include \"hash/hmac.h\"\n#include \"hash/sha256.h\"\n\n#include \"sc-memory/cpp/sc_wait.hpp\"\n#include \"sc-memory/cpp/kpm/sc_agent.hpp\"\n\n#include &lt;curl/curl.h&gt;\n\n#include &lt;rapidjson/document.h&gt;\n#include &lt;rapidjson/stringbuffer.h&gt;\n#include &lt;rapidjson/writer.h&gt;\n</code></pre> <ul> <li>Don't use <code>using namespace std</code> or other namespaces globally. You can use them locally in test cpp files or functions.</li> </ul> <p>Note</p> <p>Unfortunately, sources of <code>sc-kpm</code> does not comply these rules. But you must comply these rules!</p>"},{"location":"dev/codestyle/#indentation-and-spacing","title":"Indentation and Spacing","text":"<ul> <li>The code should use spaces for indentation. The indentation width is set to 2 spaces. The code should not use tabs.</li> </ul> <pre><code>// It is correct style.\nsc_uint32 ExampleFunc() \n{\n  if (condition) \n  {\n    // Code block\n  } \n  else \n  {\n    // Code block\n  }\n\n  return 0;\n}\n\n// It is incorrect style.\nsc_uint32 ExampleFunc() \n{\n    if (condition) \n    {\n        // Code block\n    } \n    else \n    {\n        // Code block\n    }\n\n    return 0;\n}\n</code></pre> <ul> <li>Spaces before the opening parenthesis in control statements.</li> </ul> <pre><code>// It is correct style.\nvoid ExampleFunction(sc_uint32 x) \n{\n  if (x &gt; 0) \n  {\n    // Code block\n  }\n\n  for (sc_uint32 i = 0; i &lt; x; ++i) \n  {\n    // Code block\n  }\n\n  while (x &gt; 10) \n  {\n    // Code block\n  }\n}\n\n// It is incorrect style.\nvoid ExampleFunction(sc_uint32 x) \n{\n  if(x &gt; 0) \n  {\n    // Code block\n  }\n\n  for(sc_uint32 i = 0; i &lt; x; ++i) \n  {\n    // Code block\n  }\n\n  while(x &gt; 10) \n  {\n    // Code block\n  }\n}\n</code></pre> <ul> <li>Spaces before the colon in constructor initializer lists.</li> </ul> <pre><code>// It is correct style.\nclass MyClass \n{\npublic:\n  // Constructor with initializer list\n  MyClass(sc_uint32 x, sc_uint32 y)\n    : m_x(x)\n    , m_y(y) \n  {\n    // Constructor body\n  }\n\nprivate:\n  sc_uint32 m_x; // `m` - is abbreviation of `member`\n  sc_uint32 m_y;\n  static sc_uint32 ms_maxX; // `ms` - is abbreviation of `member static`\n  static sc_uint32 ms_maxY;\n};\n</code></pre> <ul> <li>Spaces should be inserted before assignment operators and around pointer and reference qualifiers.</li> </ul> <pre><code>// It is correct style.\nsc_uint32 x = 10;\nsc_uint32 * ptr = &amp;x;\nsc_uint32 const * constPtr = &amp;x;\nsc_uint32 &amp; ref = x;\n\n// It is incorrect style.\nsc_uint32 x = 10;\nsc_uint32* ptr = &amp;x;\nconst sc_uint32 *constPtr = &amp;x;\nsc_uint32&amp; ref = x;\n</code></pre> <ul> <li>Use right-to-left order for variables/params.</li> </ul> <pre><code>// It is correct style.\nScAddr const &amp; addr; // reference to the const `ScAddr`.\n</code></pre>"},{"location":"dev/codestyle/#whitespace","title":"Whitespace","text":"<ul> <li>Remove extra whitespaces at the end of lines.</li> <li>Spaces in empty blocks and parentheses should be omitted.</li> <li>Trailing commas should be added in wrapped situations.</li> </ul> <pre><code>// It is correct style.\nstd::vector&lt;sc_uint32&gt; numbers = {\n    1,\n    2,\n    3,  // Trailing comma added\n};\n</code></pre>"},{"location":"dev/codestyle/#brace-style","title":"Brace Style","text":"<ul> <li>Braces for functions, classes, namespaces, etc., should be on a new line.</li> </ul> <pre><code>// It is correct styles.\nvoid ExampleFunction() \n{\n  // Code block\n}\n\nclass ExampleClass \n{\npublic:\n  // Class members\n};\n\nnamespace exampleNamespace \n{\n  // Namespace contents\n}\n\n// It is incorrect styles.\nvoid ExampleFunction() {\n  // Code block\n}\n\nclass ExampleClass {\npublic:\n  // Class members\n};\n\nnamespace exampleNamespace {\n  // Namespace contents\n}\n</code></pre> <ul> <li>Empty functions, classes, and namespaces should be split into separate lines.</li> </ul> <pre><code>// It is correct style.\nvoid ExampleFunction() \n{\n}\n\nclass ExampleClass \n{\n};\n\nnamespace exampleNamespace \n{\n}\n</code></pre> <ul> <li>Braces for control statements always on a new line.</li> </ul> <pre><code>// It is correct style.\nif (condition) \n{\n  // Code block\n} \nelse \n{\n  // Code block\n}\n\nfor (sc_uint32 i = 0; i &lt; 10; ++i) \n{\n  // Code block\n}\n\n// It is incorrect style.\n</code></pre> <ul> <li>Always break after a multiline string.</li> </ul> <pre><code>// It is correct style.\nstd::string multilineString = \"This is a long string that \"\n                              \"spans multiple lines.\";\n</code></pre> <ul> <li>Always break functions declarations and calls.</li> </ul> <pre><code>// It is correct style.\nsc_uint32 ExampleFunction(\n    sc_uint32 argument1, \n    sc_uint32 argument2, \n    sc_uint32 argument3, \n    sc_uint32 * result, \n    sc_uint32 * delta)\n\n// It is incorrect style.\nsc_uint32 ExampleFunction(\n    sc_uint32 argument1, sc_uint32 argument2, sc_uint32 argument3, \n    sc_uint32 * result, sc_uint32 * delta)\n</code></pre>"},{"location":"dev/codestyle/#line-length-and-wrapping","title":"Line Length and Wrapping","text":"<ul> <li> <p>The maximum column limit is set to 120 characters.</p> </li> <li> <p>Break binary operators before the operator.</p> </li> </ul> <pre><code>// It is correct style.\nsc_uint32 const result = longVariableName\n    + anotherLongVariableName\n    + yetAnotherLongVariableName;\n\n// It is incorrect style.\nsc_uint32 const result = longVariableName +\n    anotherLongVariableName +\n    yetAnotherLongVariableName;\n</code></pre> <ul> <li>Break before ternary operators.</li> </ul> <pre><code>// It is correct style.\nsc_uint32 const value = condition\n    ? trueValue\n    : falseValue;\n\n// It is incorrect style.\nsc_uint32 const value = condition ?\n    trueValue :\n    falseValue;\n</code></pre> <ul> <li>Break before braces in custom scenarios.</li> </ul> <pre><code>// It is correct style.\nif (condition) \n{\n  // Code block\n} \nelse \n{\n  // Code block\n}\n\n// It is incorrect style.\nif (condition) {\n  // Code block\n} \nelse {\n  // Code block\n}\n</code></pre> <ul> <li>In one line <code>if</code>, <code>for</code>, <code>while</code> we do not use brackets. If one line <code>for</code> or <code>while</code> is combined with one line <code>if</code>, do use brackets for cycle.</li> </ul> <pre><code>for (ScAddr const &amp; addr : addrList)\n  ctx.EraseElement(addr);\n\n...\n\nfor (ScAddr const &amp; addr : addrList)\n{\n  if (addr.IsValid())\n    return SC_TRUE;\n}\n</code></pre>"},{"location":"dev/codestyle/#naming","title":"Naming","text":""},{"location":"dev/codestyle/#c-naming","title":"C Naming","text":"<ul> <li>Macros and C-style enums must be named in UPPER_CASE, and enum values must be prefixed with a capitalized enum name.</li> <li>All other objects must be named in snake_case.</li> </ul>"},{"location":"dev/codestyle/#c-naming_1","title":"C++ Naming","text":"<ul> <li>Underscores are allowed only in prefixes for member variables and namespace names, like <code>int m_keynodeAddr; namespace sc_utils</code>.</li> <li>We use <code>using</code> keyword instead of <code>typedef</code>.</li> <li>Compile-time constants must be named in camelCase, starting with a lower-case <code>k</code>, e.g. <code>kCompileTimeConstant</code>  and marked as <code>constexpr</code> when possible.</li> <li>Values of enum classes must be named in CamelCase, e.g. <code>enum class Color { Red, Green, LightBlue };</code>.</li> </ul>"},{"location":"dev/codestyle/#comments","title":"Comments","text":"<ul> <li>Doxygen-style comments can be used.</li> </ul>"},{"location":"dev/codestyle/#check-code-style","title":"Check code style","text":"<p>Most of our coding style is specified in a configuration file for ClangFormat. To automatically format a file, install <code>clang-format</code> and run:</p> <pre><code>cd sc-machine\nclang-format -i file.cpp file.hpp other_file.cpp\n</code></pre> <p>To check all format code use script <code>check_formatting.sh</code>.</p> <pre><code>cd sc-machine\n./scripts/clang/check_formatting.sh\n</code></pre> <p>Or use script <code>format_code.sh</code> to reformat all code.</p> <pre><code>cd sc-machine\n./scripts/clang/format_code.sh\n</code></pre>"},{"location":"dev/codestyle/#tips-and-hints","title":"Tips and Hints","text":"<ul> <li>Code should compile without warnings! Just deprecated warning could be present for a short time. But if you see them,   then try to fix it in a separate commit.</li> <li>If you see outdated code which can be improved - DO IT NOW (but in the separate pull request).</li> <li>Your code should work at least on: Ubuntu 20.04 and 22.04; Debian 11; macOS platforms.</li> <li>Your code should compile well with the last gcc and clang.</li> <li>Try to avoid using any new 3rd party library if it is not fully tested and supported on supported platforms.</li> <li>Cover your code with unit tests.</li> <li>If you don't have enough time to make it right, leave a <code>// TODO(DeveloperName): need to fix it</code> comment and make  issue on GitHub.</li> </ul>"},{"location":"dev/devcontainer/","title":"Dev Container","text":""},{"location":"dev/devcontainer/#docker-development-container","title":"Docker development container","text":"<p>We recognize that recreating development environment for this project may be complicated, especially on unsupported platforms. To ease things for our developers and contributors, we created a stable, reproducible environment dubbed \"Dev container\". It can be used in any IDE or in a standalone manner, but is fully integrated with Visual Studio Code. </p>"},{"location":"dev/devcontainer/#usage","title":"Usage","text":""},{"location":"dev/devcontainer/#vscode","title":"VSCode","text":"<p>If you use VSCode as your code editor of choice, things are simple: install Docker, install <code>Remote - Containers</code> extension for VSCode, and reload the window. You should see a prompt to reopen the project in container (if it didn't appear, you can fire up <code>Reopen in Container</code> action in Command Palette). First load/build may take a while, so don't rush to cancel the process. After the window is reopened, you can open terminals, edit code and recompile the project as usual.</p>"},{"location":"dev/devcontainer/#jetbrains-ide","title":"JetBrains IDE","text":"<p>You can add our development environment container as a Docker toolchain to your JetBrains IDE. Check this guide for more info.</p>"},{"location":"dev/devcontainer/#standalone","title":"Standalone","text":"<p>Using this image directly in the terminal is also possible:</p> <ol> <li> <p>To build it, use <code>devcontainer</code> target in our Dockerfile <pre><code>docker build . -t ostis/sc-machine-builder  --target=devcontainer\n</code></pre></p> </li> <li> <p>Run the container mounting your workspace folder to <code>/sc-machine</code> inside the container. Optionally you can create a volume for <code>ccache</code> to preserve build cache across restarts: <pre><code>docker run --rm -i -t -v sc-machine_ccache:/ccache -v &lt; path to the project folder&gt;:/sc-machine ostis/sc-machine-builder\n</code></pre></p> </li> </ol>"},{"location":"sc-kpm/kpm/","title":"Agents","text":""},{"location":"sc-kpm/kpm/#scagent-implementations","title":"ScAgent Implementations","text":""},{"location":"sc-kpm/kpm/#get-decomposition-agent","title":"Get Decomposition Agent","text":"<p>It is an agent that get decomposition of subject domain in JSON format</p> <p>Action class:</p> <p><code>action_get_decomposition</code></p> <p>Parameters:</p> <ul> <li><code>subjDomain</code> - subject domain node;</li> <li><code>level</code> - link that stores decomposition level (unnecessary parameter, by default value of <code>level</code> parameter is <code>1</code>);</li> <li><code>lang</code> - language node;</li> <li><code>relation of decomposition</code> - relation node by which an entity is decomposed.</li> </ul> <p>Example:</p> <p>Example of an input structure:</p> <p></p> <p>Example of an output structure:</p> <p></p> <p>Link result:</p> <pre><code>{\n   &lt;main_entity_addr&gt;: {\n      \"decomposition\": {\n            &lt;entity_1_addr&gt;: {\n               \"decomposition\": null,\n               \"idtf\": \"Entity 1\",\n               \"position\": 0\n            },\n            &lt;entity_2_addr&gt;: {\n               \"decomposition\": null,\n               \"idtf\": \"Entity 2\",\n               \"position\": 1\n            },\n            &lt;entity_3_addr&gt;: {\n               \"decomposition\": null,\n               \"idtf\": \"Entity 3\",\n               \"position\": 2\n            },\n            &lt;entity_4_addr&gt;: {\n               \"decomposition\": {\n                  &lt;entity_4_1_addr&gt;: {\n                     \"decomposition\": null,\n                     \"idtf\": \"Entity 4.1\",\n                     \"position\": 0\n                  },\n                  &lt;entity_4_2_addr&gt;: {\n                     \"decomposition\": null,\n                     \"idtf\": \"Entity 4.2\",\n                     \"position\": 1\n                  },\n               },\n               \"idtf\": \"Entity 4\",\n               \"position\": 3\n            },\n      },\n      \"idtf\": \"Main Entity\",\n      \"position\": 0\n   }\n}\n</code></pre> <p>Result:</p> <ul> <li><code>SC_RESULT_OK</code> - result link is generated.</li> <li><code>SC_RESULT_ERROR</code> - internal error in the link generation.</li> <li><code>SC_RESULT_ERROR_INVALID_PARAMS</code> - internal error. This happens when subject domain node is invalid.</li> </ul>"},{"location":"sc-memory/api/cpp/agents/","title":"C++ Agents API","text":"<p>Warning</p> <p>This documentation is correct for only versions of sc-machine that &gt;= 0.9.0.</p> <p>This API provides functionality to implement sc-agents on C++.</p> <p>Each sc-agent on C++ refers to program entity that performs actions in sc-memory and can be called only by emission of sc-event on which this program entity is registered. In C++ all sc-agents are registered by sc-memory or sc-modules connected to sc-memory. Each sc-module can register certain sc-agents, not only one. Division by sc-modules are usually  performed logically by developer.</p>"},{"location":"sc-memory/api/cpp/agents/#scmodule","title":"ScModule","text":"<p>It is a dynamic library. It implements specified module class. To create module you need to do the next steps:</p> <ol> <li>Create directory for your module in project using sc-machine. For example, <code>my-module</code>.</li> <li>Go to created directory.</li> <li>Create file <code>CMakeLists.txt</code> with content (replace <code>my_module</code> (module name) to your one):</li> </ol> <p>CMakeLists.txt</p> <pre><code># Define alias for directory path with your sc-module and sc-agents in it.\nset(MY_AGENT_SRC ${CMAKE_CURRENT_LIST_DIR})\n\n# Collect your sc-agent sources.\nset(SOURCES\n    \"my_module.cpp\"\n)\nset(HEADERS\n    \"my_module.hpp\"\n)\n\n# Include using other directories.\ninclude_directories(${MY_AGENT_SRC} ${SC_MEMORY_SRC})\n\n# Create and link your library with using libraries.\nadd_library(my_lib SHARED ${SOURCES} ${HEADERS})\nadd_dependencies(my_lib sc-memory)\ntarget_link_libraries(my_lib sc-memory)\n\n# Specify where code for your sc-agent will be generated.\nsc_codegen_ex(my_lib ${MY_AGENT_SRC} \"${MY_AGENT_SRC}/generated\")\n</code></pre> <p>After that you need to create two files (.cpp and .hpp):</p> <p>my_module.hpp</p> <pre><code>#pragma once\n\n#include &lt;sc-memory/sc_module.hpp&gt;\n\n#include \"my_module.generated.hpp\"\n\n// Your module class for sc-agents\nclass MyModule : public ScModule\n{\n  // Priority that can be used during load all sc-modules.\n  SC_CLASS(LoadOrder(10))\n  SC_GENERATED_BODY()\n\n  virtual sc_result InitializeImpl() override;\n  virtual sc_result ShutdownImpl() override;\n}\n</code></pre> <p>my_module.cpp</p> <pre><code>#include \"my_module.hpp\"\n\nSC_IMPLEMENT_MODULE(MyModule)\n\n// This method will be called once. \n// It is usually used to register sc-agents and sc-keynodes.\nsc_result MyModule::InitializeImpl()\n{\n  return SC_RESULT_OK;\n}\n\n// This method will be called once. \n// It is usually used to unregister sc-agents and sc-keynodes.\nsc_result MyModule::ShutdownImpl()\n{\n  return SC_RESULT_OK;\n}\n</code></pre>"},{"location":"sc-memory/api/cpp/agents/#scagent","title":"ScAgent","text":"<p>To create sc-agent implementation you need:</p> <ol> <li>Create source and header file for sc-agent implementation.</li> <li>Add created files into <code>CMakeLists.txt</code>.</li> <li>Register implemented sc-agent in created sc-module.</li> </ol> <p>CMakeLists.txt</p> <pre><code>...\n\nset(SOURCES\n  \"my_module.cpp\"\n+ \"my_agent.cpp\"\n)\nset(HEADERS\n  \"my_module.hpp\"\n+ \"my_agent.hpp\"\n)\n\n...\n</code></pre> <p>my_agent.hpp</p> <pre><code>#pragma once\n\n#include \"sc-memory/kpm/sc_agent.hpp\"\n#include \"sc-memory/sc_keynodes.hpp\"\n\n#include \"my_agent.generated.hpp\"\n\n// Use namespaces to avoid conflicts in names and provide modularity in your code.\nnamespace myAgents\n{\n\nclass MyAgent : public ScAgent\n{\n  // Specify action class and sc-event type on which this sc-agent will be called.\n  SC_CLASS(\n      Agent, \n      Event(ScKeynodes::my_action_class, ScEvent::Type::AddOutputEdge)\n  )\n  // This sc-agent can be called if sc-connector is created from sc-element \n  // with sc-address `ScKeynodes::my_action_class` to some sc-element.\n  SC_GENERATED_BODY()\n}\n\n}\n</code></pre> <p>my_agent.cpp</p> <pre><code>#include \"my_agent.hpp\"\n\n#include \"sc-memory/sc_memory.hpp\"\n\nnamespace myAgents\n{\n\n// my_action_class -&gt; ...;;\nSC_AGENT_IMPLEMENTATION(MyAgent)\n{\n  // Implement sc-agent logic here. \n  // Use Core C++ API to implement logic of your sc-agent.\n  return SC_RESULT_OK;\n}\n\n}\n</code></pre> <p><code>SC_AGENT_IMPLEMENTATION</code> is a macro that inserts generated code to minimize work. You just insert this one (with class name as parameter), and implement it like a function. During implementation, you can use such variables:</p> <ul> <li><code>listenAddr</code> - sc-address of sc-element listening for sc-events in sc-memory (see ScEvent);</li> <li><code>edgeAddr</code> - sc-address of sc-connector that will be created to or from listening sc-element with sc-address  <code>listenAddr</code> (if sc-event type is <code>ScEventEraseElement</code> or <code>ScEventContentChanged</code>, then value of this variable is empty  sc-address);</li> <li><code>otherAddr</code> - sc-address of target or source sc-element of sc-connector with sc-address <code>edgeAddr</code> (if sc-event type  is <code>ScEventEraseElement</code> or <code>ScEventContentChanged</code>, then value of this variable is empty sc-address);</li> <li><code>m_memoryCtx</code> - sc-memory context of calling sc-agent that can be used to work with sc-memory.</li> </ul> <p>If sc-agent finished work without any errors, then it must return <code>SC_RESULT_OK</code>, otherwise - one of code error <code>SC_RESULT_ERROR_...</code>.</p> <p>Possible results:</p> <ul> <li><code>SC_RESULT_ERROR</code> - unknown error;</li> <li><code>SC_RESULT_OK</code> - no any errors (successfully finish);</li> <li><code>SC_RESULT_ERROR_INVALID_PARAMS</code> - invalid parameters of agent;</li> <li><code>SC_RESULT_ERROR_INVALID_TYPE</code> - invalid type error (invalid type of data of something else);</li> <li><code>SC_RESULT_ERROR_INVALID_STATE</code> - invalid state of processing data;</li> <li><code>SC_RESULT_ERROR_NOT_FOUND</code> - something wasn't found (for example: can't resolve element by identifier).</li> </ul> <p>my_module.cpp</p> <pre><code>#include \"my_module.hpp\"\n\n+ #include \"my_agent.hpp\"\n\nSC_IMPLEMENT_MODULE(MyModule)\n\nsc_result MyModule::InitializeImpl()\n{\n+ SC_AGENT_REGISTER(myAgents::MyAgent);\n  return SC_RESULT_OK;\n}\n\nsc_result MyModule::ShutdownImpl()\n{\n+ SC_AGENT_UNREGISTER(myAgents::MyAgent);\n  return SC_RESULT_OK;\n}\n</code></pre> <p>Some important rules:</p> <ul> <li>You can implement more than one <code>ScAgent</code> class in on source/header file;</li> <li>Don't use any other memory contexts instead of <code>m_memoryCtx</code> in <code>ScAgent</code> implementation;</li> <li>You need always include <code>&lt;you_header&gt;.generated.hpp</code> file into your header, to link your sc-agent code with generated  metadata. This include must be the last one in a file.</li> </ul>"},{"location":"sc-memory/api/cpp/agents/#scevent","title":"ScEvent","text":"<p>This type of objects allows you to subscribe to any events in sc-memory. There are C++ classes that correspond to specified event types:</p> <ul> <li><code>ScEventAddOutputEdge</code> - emits each time, when output (outgoing) sc-connector (from specified sc-element) is created;</li> <li><code>ScEventAddInputEdge</code> - emits each time, when input (ingoing) sc-connector (into specified sc-element) is created;</li> <li><code>ScEventRemoveOutputEdge</code> - emits each time, when output (outgoing) sc-connector (from specified sc-element) is erased;</li> <li><code>ScEventRemoveInputEdge</code> - emits each time, when input (ingoing) sc-connector (into specified sc-element) is erased;</li> <li><code>ScEventEraseElement</code> - emits, when specified sc-element is erased;</li> <li><code>ScEventContentChanged</code> - emits each time, when content of specified sc-link is changed.</li> </ul> <p>Each event constructor takes 3 parameters:</p> <ul> <li><code>context</code> - <code>ScMemoryContext</code> that will be used to work with event;</li> <li><code>addr</code> - <code>ScAddr</code> of sc-element that need to be listened for a specified event;</li> <li><code>func</code> - delegate to a callback function, that will be called on each event emit   (<code>bool func(ScAddr const &amp; listenAddr, ScAddr const &amp; edgeAddr, ScAddr const &amp; otherAddr)</code>).   Description of parameters for this function you can see in table below (for each event type).</li> </ul> <p>Note</p> <p>Callback function will be called in another thread!</p> <p>The table of description (parameters of callback function named on pictures, if there are no parameter name on picture, then it's would have an empty value):</p> Class Description ScEventAddOutputEdge        Callback calls each time, when some sc-connector <code>edgeAddr</code> between listening sc-element with <code>listenAddr</code> and some sc-element with <code>otherAddr</code> is created.        Example C++ code:       <pre><code>\nauto const callback = [](ScAddr const &amp; listenAddr,\n                         ScAddr const &amp; edgeAddr,\n                         ScAddr const &amp; otherAddr)\n{\n    // listenAddr - sc-address of source sc-element\n    //  (listen it in sc-event)\n    // edgeAddr - sc-address of added output sc-connector\n    // otherAddr - sc-address of target element of added \n    //  sc-connector\n    ...\n    return SC_TRUE; // if failed, then return SC_FALSE\n};\nScEventAddOutputEdge event(context, addr, callback);\n      </code></pre> ScEventAddInputEdge        Callback calls each time, when some sc-connector <code>edgeAddr</code> between some sc-element with <code>otherAddr</code> and listening sc-element with <code>listenAddr</code> is created.        Example C++ code:       <pre><code>\nauto const callback = [](ScAddr const &amp; listenAddr,\n                         ScAddr const &amp; edgeAddr,\n                         ScAddr const &amp; otherAddr)\n{\n    // listenAddr - sc-address of target sc-element\n    //  (listen it in sc-event)\n    // edgeAddr - sc-address of added input sc-connector\n    // otherAddr - sc-address of source sc-element of added \n    //  sc-connector\n    ...\n    return SC_TRUE; // if failed, then return SC_FALSE\n};\nScEventAddInputEdge event(context, addr, callback);\n      </code></pre> ScEventRemoveOutputEdge        Callback calls each time, when some sc-connector <code>edgeAddr</code> between listening sc-element with <code>listenAddr</code> and some sc-element with <code>otherAddr</code> is erased.        Example C++ code:       <pre><code>\nauto const callback = [](ScAddr const &amp; listenAddr,\n                         ScAddr const &amp; edgeAddr,\n                         ScAddr const &amp; otherAddr)\n{\n    // listenAddr - sc-address of source sc-element\n    //  (listen it in sc-event)\n    // edgeAddr - sc-address of erased output sc-connector\n    // otherAddr - sc-address of target sc-element of erased \n    //  sc-connector\n    ...\n    return SC_TRUE; // if failed, then return SC_FALSE\n};\nScEventRemoveOutputEdge event(context, addr, callback);\n      </code></pre> ScEventRemoveInputEdge        Callback calls each time, when some sc-connector <code>edgeAddr</code> between some sc-element with <code>otherAddr</code> and listening sc-element with <code>listenAddr</code> is erased.        Example C++ code:       <pre><code>\nauto const callback = [](ScAddr const &amp; listenAddr,\n                         ScAddr const &amp; edgeAddr,\n                         ScAddr const &amp; otherAddr)\n{\n    // listenAddr - sc-address of target sc-element\n    //  (listen it in sc-event)\n    // edgeAddr - sc-address of erased input sc-connector\n    // otherAddr - sc-address of sc-element of erased\n    //  sc-connector\n    ...\n    return SC_TRUE; // if failed, then return SC_FALSE\n};\nScEventRemoveOutputEdge event(context, addr, callback);\n      </code></pre> ScEventEraseElement      Callback calls when listening sc-element with <code>listenAddr</code> is erased.      Example C++ code:     <pre><code>\nauto const callback = [](ScAddr const &amp; listenAddr,\n                         ScAddr const &amp; edgeAddr,\n                         ScAddr const &amp; otherAddr)\n{\n  // listenAddr - sc-address of erased sc-element\n  //  (listen it in sc-event)\n  // edgeAddr - empty sc-address\n  // otherAddr - empty sc-address\n  ...\n  return SC_TRUE; // if failed, then return SC_FALSE\n};\nScEventEraseElement event(context, addr, callback);\n    </code></pre> ScEventContentChanged        Callback calls when content of listening sc-link with <code>listenAddr</code> is changed.        Example C++ code:       <pre><code>\nauto const callback = [](ScAddr const &amp; listenAddr,\n                         ScAddr const &amp; edgeAddr,\n                         ScAddr const &amp; otherAddr)\n{\n  // listenAddr - sc-address of element that has\n  //   content changed (listen it in sc-event)\n  // edgeAddr - empty sc-address\n  // otherAddr - empty sc-address\n  ...\n  return SC_TRUE; // if failed, then return SC_FALSE\n};\nScEventContentChanged evt(context, addr, callback);\n      </code></pre>"},{"location":"sc-memory/api/cpp/agents/#scwait","title":"ScWait","text":"<p>This type of objects is used to wait until some event emits. It is usually used, when one of an <code>ScAgent</code> wants to wait  result of another one. There are next kind of <code>ScWait</code> objects:</p> <ul> <li><code>ScWait</code>- lock run flow until simple event emits. You can see the list of these events in the Class properties table (   ScEvent property);</li> <li><code>ScWaitCondition</code> - lock run flow until simple event emits and specified conditional check returns <code>SC_TRUE</code>. In other   words, this works like an <code>ScWait</code>, but returns to run flow if special condition function returns <code>SC_TRUE</code>. Condition   function receives 3 parameters (see ScEvent for more details about them).</li> </ul> <p>There are some examples of usage for specified <code>ScWait</code> objects:</p> <ul> <li>Wait input sc-connector into sc-element with <code>addr</code>:</li> </ul> <pre><code>ScWait&lt;ScEventAddInputEdge&gt; waiter(context, addr);\nwaiter.Wait();\n</code></pre> <ul> <li>Wait input sc-connector into sc-element with <code>listenAddr</code>, with condition:</li> </ul> <pre><code>auto const check = [](ScAddr const &amp; listenAddr,\n                      ScAddr const &amp; edgeAddr,\n                      ScAddr const &amp; otherAddr)\n{\n  ... // Check condition here.\n  // Return SC_TRUE or SC_FALSE depending on condition.\n  return SC_FALSE;\n};\nScWaitCondition&lt;ScEventAddInputEdge&gt; waiter(context, addr, SC_WAIT_CHECK(check));\n// Provide wait time value.\nwaiter.Wait(10000);\n// By default, wait time value is 5000.\n</code></pre> <p>There are some yet implemented most common waiters:</p> <ul> <li><code>ScWaitActionFinished</code> - wait until specified agent will be finished. Example:</li> </ul> <pre><code>...\nScWaitActionFinished waiter(context, commandAddr);\nwaiter.Wait();\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/agents/#frequently-asked-questions","title":"Frequently Asked Questions","text":""},{"location":"sc-memory/api/cpp/core/api/","title":"C++ Core API","text":"<p>Warning</p> <p>This documentation is correct for only versions of sc-machine that &gt;= 0.9.0.</p> <p>The API provides core functionality for creating, retrieving and erasing sc-elements in sc-memory. This sc-memory is designed to represent knowledge in a structured and graph-based manner.</p> <p>A sc-memory consists of sc-elements. Sc-elements can be grouped into sc-constructions (semantic graphs or knowledge graphs).  Among sc-elements there are sc-nodes, sc-links and sc-connectors between them. All sc-elements have syntactic and  semantic sc-types. Sc-connectors are divided into non-oriented sc-connectors (sc-edges) and oriented sc-connectors  (sc-arcs). Each sc-connector have source and target sc-elements. These sc-elements can be sc-nodes, sc-links or  sc-connectors. All these attributes of sc-elements and sc-element structures are hidden from user, but you can get  these features using this API.</p> <p>Note</p> <p>All API methods are thread-safe.</p> <p>Note</p> <p>To include this API provide <code>#include &lt;sc-memory/sc_memory.hpp&gt;</code> in your hpp source.</p>"},{"location":"sc-memory/api/cpp/core/api/#scaddr","title":"ScAddr","text":"<p>Each sc-element has a sc-address with which you can obtain information about this sc-element.</p> <pre><code>...\nScAddr elementAddr1 = // some call of the API method 1\nScAddr elementAddr2 = // some call of the API method 2\n// Compare sc-addresses.\nbool const isAddrsEqual = elementAddr1 == elementAddr2;\n</code></pre>"},{"location":"sc-memory/api/cpp/core/api/#scmemorycontext","title":"ScMemoryContext","text":"<p>It is a class provided all API methods for creating, manipulating, retrieving and erasing sc-elements in sc-memory. It refers to set of attributes and rights of some subject of action in sc-memory (user or agent) that are used in  during API methods completion.</p> <pre><code>...\n// To create such context use constructor of ScMemoryContext \n// providing system identifier of subject of action.\nScMemoryContext context{\"my_name\"};\n// After you can use this object to call any API methods.\n</code></pre> <p>Note</p> <p>Don't use constructor of ScMemoryContext, providing sc_permissions argument. It can be unsafe. It will be  deleted in the further versions of sc-machine. </p>"},{"location":"sc-memory/api/cpp/core/api/#createnode","title":"CreateNode","text":"<p>To create sc-nodes you can use the method <code>CreateNode</code>, to create sc-links - the method <code>CreateLink</code>, to create sc-connectors between them - the method <code>CreateEdge</code>. All these methods check passed sc-types. If specified sc-type is not valid, then a method throws the exception <code>utils::ExceptionInvalidParams</code> with description of this error.</p> <pre><code>...\n// Create sc-node and get sc-address in sc-memory of it.\nScAddr const &amp; nodeAddr = context.CreateNode(ScType::NodeConst);\n// Specified sc-type must be one of ScType::Node... type.\n</code></pre>"},{"location":"sc-memory/api/cpp/core/api/#createlink","title":"CreateLink","text":"<pre><code>...\n// Create sc-link and get sc-address in sc-memory of it.\nScAddr const &amp; linkAddr = context.CreateLink(ScType::LinkConst);\n// Specified sc-type must be one of ScType::Link... type.\n</code></pre> <p>Note</p> <p>Now all sc-links are not sc-nodes. It can be fixed in the further versions of sc-machine. But you can use  the method <code>CreateNode</code> to create sc-links.</p>"},{"location":"sc-memory/api/cpp/core/api/#createedge","title":"CreateEdge","text":"<pre><code>...\n// Create sc-arc between sc-node and sc-link and get sc-address in \n// sc-memory of it.\nScAddr const &amp; arcAddr = context.CreateEdge(\n    ScType::EdgeAccessConstPosPerm, nodeAddr, linkAddr);\n// Specified sc-type must be one of ScType::Edge... type.\n</code></pre> <p>If specified sc-addresses of source and target sc-elements are not valid, then the method throws exception <code>utils::ExceptionInvalidParams</code> with description that some of specified sc-addresses is not valid.</p> <p>Note</p> <p>Although this method is called incorrectly and may be misleading, but you can create any sc-connectors using it.</p>"},{"location":"sc-memory/api/cpp/core/api/#iselement","title":"IsElement","text":"<p>To check if specified sc-address is valid in sc-memory you can use the method <code>IsElement</code>. Valid sc-address refers to sc-address that exists in sc-memory and that corresponds some sc-element in it.</p> <pre><code>...\n// Check if all created sc-elements are valid.\nbool const isNodeValid = context.IsElement(nodeAddr);\nbool const isLinkValid = context.IsElement(linkAddr);\nbool const isEdgeValid = context.IsElement(arcAddr);\n</code></pre> <p>Note</p> <p>You can check if specified sc-address is not empty calling from this sc-address object method <code>IsValid</code>. But it is preferable to use <code>IsElement</code>, it checks if provided sc-address exists and valid in sc-memory. </p>"},{"location":"sc-memory/api/cpp/core/api/#getelementtype","title":"GetElementType","text":"<p>If it needs you can get sc-element types by its sc-addresses. If specified sc-address is not valid, then the method  throws exception <code>utils::ExceptionInvalidParams</code> with description that specified sc-address is not valid.</p> <pre><code>...\n// Get created sc-elements sc-types.\nScType const &amp; nodeType = context.GetElementType(nodeAddr);\nScType const &amp; linkType = context.GetElementType(linkAddr);\nScType const &amp; arcType = context.GetElementType(arcAddr);\n</code></pre>"},{"location":"sc-memory/api/cpp/core/api/#setelementsubtype","title":"SetElementSubtype","text":"<p>You can change semantic sc-type of sc-element. Use the method <code>SetElementSubtype</code> and provide semantic sc-type for syntactic sc-type for sc-element.</p> <pre><code>...\n// Create sc-node and get sc-address in sc-memory of it.\nScAddr const &amp; nodeAddr = context.CreateNode(ScType::Node);\nbool const isSubtypeElementChanged \n    = context.SetElementSubtype(node, ScType::NodeConst);\n// The value of `isSubtypeElementChanged` must be equal to `SC_TRUE`.\n</code></pre> <p>Note</p> <p>Don't use this method to change syntactic sc-type for sc-element. It is misleading.</p>"},{"location":"sc-memory/api/cpp/core/api/#getedgeinfo","title":"GetEdgeInfo","text":"<p>To get incident (source and target) sc-elements you can use methods <code>GetEdgeInfo</code>, <code>GetEdgeSource</code> and <code>GetEdgeTarget</code>. If specified sc-address is not valid, then this methods throw exception <code>utils::ExceptionInvalidParams</code> with description  that specified sc-address of sc-connector is not valid.</p> <pre><code>...\n// Get sc-arc incident sc-elements.\nScAddr sourceAddr, targetAddr;\ncontext.GetEdgeInfo(arcAddr, sourceAddr, targetAddr);\n// The sc-address `sourceAddr` must be equal to the sc-address `nodeAddr` \n// and the sc-address `targetAddr` must be equal to the sc-address `linkAddr`.\n...\n// Or get sc-arc incident source and target sc-elements separately.\nScAddr const &amp; sourceAddr = context.GetEdgeSource(arcAddr);\n// The sc-address `sourceAddr` must be equal to the sc-address `nodeAddr`.\nScAddr const &amp; targetAddr = context.GetEdgeTarget(arcAddr);\n// The sc-address `targetAddr` must be equal to the sc-address `linkAddr`.\n</code></pre> <p>To find previously created sc-constructions you can use 3-element sc-iterators and 5-element sc-iterators from C++ API. The image below shows numeration of sc-elements in 3-element (left) and 5-element (right) sc-iterators.</p> <p>Iterators element numeration</p> <p>For both of them you have two approaches. First approach is to use simple while loop. It is suitable, when you need to break this loop depending on logic:</p>"},{"location":"sc-memory/api/cpp/core/api/#sciterator3","title":"ScIterator3","text":"<pre><code>...\n// Create sc-iterator for searching all sc-element sc-addresses \n// with unknown sc-type belonging to sc-set with sc-address `setAddr`.\nScIterator3Ptr it3 = context.Iterator3(\n            setAddr,\n            ScType::EdgeAccessConstPosPerm,\n            ScType::Unknown);\n// Use it3-Next() to go to the next appropriate by condition sc-construction.\nwhile (it3-&gt;Next())\n{\n  // To get values use `it3-&gt;Get(index)`, where index in range [0; 2]. \n  // It returns `SC_TRUE`, if the next appropriate construction is found, \n  // otherwise `SC_FALSE`.\n  ... // Write your code to handle found sc-construction.\n}\n</code></pre>"},{"location":"sc-memory/api/cpp/core/api/#sciterator5","title":"ScIterator5","text":"<pre><code>...\n// Create sc-iterator for searching all sc-node sc-addresses, \n// which pairs with sc-element with address `setAddr` belong to the relation \n// with sc-address `nrelDecompositionAddr`.\nScIterator5Ptr it5 = context.Iterator5(\n        setAddr,\n        ScType::EdgeDCommonConst,\n        ScType::NodeConst,\n        ScType::EdgeAccessConstPosPerm,\n        nrelDecompositionAddr);\n// Use `it5-Next()` to go to the next appropriate by condition sc-construction. \n// It returns `SC_TRUE`, if the next appropriate construction is found, \n// otherwise `SC_FALSE`.\nwhile (it5-&gt;Next())\n{\n  // To get values use `it5-&gt;Get(index)`, where index in range [0; 4].\n  ... // Write your code to handle found sc-construction.\n}\n</code></pre> <p>Second approach allows you to iterate 3-element and 5-element constructions with less code, and it is suitable when you need to iterate all results.</p> <p>Note</p> <p>Use next methods if you need to iterate all results. Because it more clearly.</p>"},{"location":"sc-memory/api/cpp/core/api/#foreachiter3","title":"ForEachIter3","text":"<pre><code>...\n// Create callback-based sc-iterator for searching all sc-element sc-addresses \n// with unknown sc-type belonging to sc-set with sc-address `setAddr`.\ncontext.ForEachIter3(\n    setAddr,\n    ScType::EdgeAccessConstPosPerm,\n    ScType::Unknown,\n    [] (ScAddr const &amp; srcAddr, ScAddr const &amp; edgeAddr, ScAddr const &amp; trgAddr)\n{\n  // srcAddr equal to the 0th value of iterator\n  // edgeAddr equal to the 1st value of iterator\n  // trgAddr equal to the 2d value of iterator\n  ... // Write your code to handle found sc-construction.\n});\n</code></pre>"},{"location":"sc-memory/api/cpp/core/api/#foreachiter5","title":"ForEachIter5","text":"<pre><code>...\n// Create callback-based sc-iterator for searching all sc-node sc-addresses, \n// which pairs with sc-element with address `setAddr` belong to the relation \n// with sc-address `nrelDecompositionAddr`.\ncontext.ForEachIter5(\n  setAddr,\n  ScType::EdgeDCommonConst,\n  ScType::NodeConst,\n  ScType::EdgeAccessConstPosPerm,\n  nrelDecompositionAddr\n  [] (ScAddr const &amp; srcAddr, \n      ScAddr const &amp; edgeAddr, \n      ScAddr const &amp; trgAddr, \n      ScAddr const &amp; edgeAttrAddr, \n      ScAddr const &amp; attrAddr)\n{\n  // srcAddr equal to the 0th value of sc-iterator\n  // edgeAddr equal to the 1st value of sc-iterator\n  // trgAddr equal to the 2d value of sc-iterator\n  // edgeAttrAddr equal to the 3rd value of sc-iterator\n  // attrAddr equal to the 4th value of sc-iterator\n  ... // Write your code to handle found sc-construction.\n});\n</code></pre>"},{"location":"sc-memory/api/cpp/core/api/#eraseelement","title":"EraseElement","text":"<p>All sc-elements can be erasing from sc-memory. For this you can use the method <code>EraseElement</code>.</p> <pre><code>...\n// Erase all created sc-elements.\nbool const isNodeErased = context.EraseElement(nodeAddr);\n// The sc-elements with sc-addresses `nodeAddr` and `arcAddr` must be deleted.\nbool const isArcErased = context.EraseElement(arcAddr);\n// The sc-element with sc-address `targetAddr` must be deleted.\n</code></pre>"},{"location":"sc-memory/api/cpp/core/api/#setlinkcontent","title":"SetLinkContent","text":"<p>Besides creating and checking elements, the API also supports updating and removing content of sc-links. If specified sc-element is a sc-link, you can set content into it. Re-installing new content into a sc-link removes the previous content from this sc-link. If specified sc-address is not valid, then the method throws exception  <code>utils::ExceptionInvalidParams</code> with description that specified sc-address is not valid.</p> <pre><code>...\nScAddr const &amp; linkAddr1 = context.CreateLink(ScType::LinkConst);\n// Set string content into created sc-link.\ncontext.SetLinkContent(linkAddr1, \"my content\");\n\nScAddr const &amp; linkAddr2 = context.CreateLink(ScType::LinkConst);\n// Set numeric content into created sc-link.\ncontext.SetLinkContent(linkAddr2, 10f);\n...\n</code></pre> <p>Note</p> <p>Don't use result boolean value, it doesn't mean anything.</p>"},{"location":"sc-memory/api/cpp/core/api/#getlinkcontent","title":"GetLinkContent","text":"<p>To get existed content from sc-link you can use the method <code>GetLinkContent</code>. A content can be represented as numeric or  string. If content doesn't exist in sc-link, then the method <code>GetLinkContent</code> will return <code>SC_FALSE</code> and result content will be empty.</p> <pre><code>...\n// Get string content from sc-link.\nstd::string stringContent;\nbool const stringContentExist \n  = context.GetLinkContent(linkAddr1, stringContent);\n\n// Get numeric content from sc-link.\nfloat numericContent;\nbool const numericContentExist \n  = context.GetLinkContent(linkAddr1, numericContent);\n...\n</code></pre> <p>Note</p> <p>You can set empty content into sc-link, but it means that this sc-link has content and this method for this  sc-link returns <code>SC_TRUE</code>.</p>"},{"location":"sc-memory/api/cpp/core/api/#findlinksbycontent","title":"FindLinksByContent","text":"<p>You can find sc-links by its content. For this use the method <code>FindLinksByContent</code>.</p> <pre><code>...\n// Find sc-links with specified string content.\nScAddrVector const &amp; linkAddrs1 = context.FindLinksByContent(\"my content\");\n// The vector `linkAddrs1` must contain sc-address `linkAddr1`.\n\n// Find sc-links with specified numeric content.\nScAddrVector const &amp; linkAddrs2 = context.FindLinksByContent(10f);\n// The vector `linkAddrs2` must contain sc-address `linkAddr2`.\n</code></pre>"},{"location":"sc-memory/api/cpp/core/api/#findlinksbycontentsubstring","title":"FindLinksByContentSubstring","text":"<p>And you can find sc-links by its content substring. For this use the method <code>FindLinksByContentSubstring</code>.</p> <pre><code>...\n// Find sc-links with specified string content substring.\nScAddrVector const &amp; linkAddrs1 \n  = context.FindLinksByContentSubstring(\"my cont\");\n// The vector `linkAddrs1` must contain sc-address `linkAddr1`.\n</code></pre>"},{"location":"sc-memory/api/cpp/core/api/#scexception","title":"ScException","text":"<p>To declare your own exceptions inherit from class <code>ScException</code>.</p> <pre><code>class MyException final : public ScException\n{\npublic:\n  explicit MyException(std::string const &amp; msg) \n    : ScException(\"MyException: \" + msg)\n  {}\n};\n</code></pre> <p>To throw exceptions use <code>SC_THROW_EXCEPTION(exceptionName, message);</code>.</p> <pre><code>SC_THROW_EXCEPTION(MyException, \"It is my exception.\");\n</code></pre> <p>Throw exception for a non-implemented part of code.</p> <pre><code>SC_NOT_IMPLEMENTED(\"This code is not implemented.\");\n</code></pre>"},{"location":"sc-memory/api/cpp/core/api/#sclogger","title":"ScLogger","text":"<p>There are some standard macros which you can use for logging your code. They are encapsulate the class <code>ScLogger</code> to prevent unappropriated access to it and provide metaprogramming during message logging.</p> Macro Message prefix Message color Log levels <code>SC_LOG_DEBUG(msg);</code> <code>[Debug]</code> <code>ScConsole::Color::Grey</code> Debug <code>SC_LOG_INFO(msg);</code> <code>[Info]</code> <code>ScConsole::Color::LightBlue</code> Debug, Info <code>SC_LOG_WARNING(msg);</code> <code>[Warning]</code> <code>ScConsole::Color::Yellow</code> Debug, Info, Warning <code>SC_LOG_ERROR(msg);</code> <code>[Error]</code> <code>ScConsole::Color::Red</code> Debug, Info, Warning, Error <p>Now you can not add log levels. But if you want to use another prefixes or colors in logging you can use <code>SC_LOG_INFO_COLOR(msg, color);</code>. It prints colored info message. Look color constants in <code>ScConsole::Color</code>.</p> <p>Log level can be configured in config file <code>sc-machine.ini</code>. Change parameter <code>log_level</code> in group <code>[sc-memory]</code> by one from the list <code>[Debug, Info, Warning, Error]</code>. See Config file example to learn more about groups and their parameters.</p>"},{"location":"sc-memory/api/cpp/core/api/#extended-api","title":"Extended API","text":"<p>Described methods are part of Core C++ API of sc-memory. You can see and use Extended C++ API of sc-memory:</p> <ul> <li>ScHelper C++ API to manipulate with system identifiers of sc-elements; </li> <li>ScTemplate C++ API, providing functionality for creating, manipulating and retrieving  large graph structures.</li> </ul>"},{"location":"sc-memory/api/cpp/core/api/#frequently-asked-questions","title":"Frequently Asked Questions","text":"<ul> <li>What is the difference between ScType::EdgeDCommonConst and ScType::EdgeAccessConstPosPerm?</li> <li>How I can specify empty ScAddr?</li> <li>Why <code>SC_TRUE</code> and <code>SC_FALSE</code> are used instead of <code>true</code> and <code>false</code>?</li> </ul>"},{"location":"sc-memory/api/cpp/core/api/#what-is-the-difference-between-sctypeedgedcommonconst-and-sctypeedgeaccessconstposperm","title":"What is the difference between ScType::EdgeDCommonConst and ScType::EdgeAccessConstPosPerm?","text":"<p><code>ScType::EdgeDCommonConst</code> is a sc-type of sc-arc that connects two sc-elements in some relation. <code>ScType::EdgeAccessConstPosPerm</code> is a sc-type of sc-arc that denotes access of target sc-element to source sc-element. The sc-arc with sc-type <code>ScType::EdgeDCommonConst</code> between some two sc-elements can be transformed to sc-node to which  this two sc-elements belong.</p>"},{"location":"sc-memory/api/cpp/core/api/#how-i-can-specify-empty-scaddr","title":"How I can specify empty ScAddr?","text":"<p>Empty <code>ScAddr</code> is the sc-address that has hash that equals to <code>0</code>.</p> <pre><code>...\nScAddr addr;\n// Here `addr` is empty.\n\nmyFunc(addr);\n// or\nmyFunc(ScAddr::Empty);\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/core/api/#why-sc_true-and-sc_false-are-used-instead-of-true-and-false","title":"Why <code>SC_TRUE</code> and <code>SC_FALSE</code> are used instead of <code>true</code> and <code>false</code>?","text":"<p>We try to override standard types. In the future, it allows you to replace types. For example, you have <code>sc_char</code> that override <code>char</code> and you want to use more symbols using <code>wchar_t</code> instead. To do it you can replace <code>char</code> by <code>wchar_t</code>.</p>"},{"location":"sc-memory/api/cpp/extended/helper_api/","title":"ScHelper API","text":"<p>Warning</p> <p>This documentation is correct for only versions of sc-machine that &gt;= 0.9.0.</p> <p>This API allows to work with system identifiers of sc-elements. All methods of this API are the part of class  <code>ScMemoryContext</code>. So, you can use they from object of class <code>ScMemoryContext</code>.</p> <p>A system identifier is an identifier that is unique within the entire knowledge base. This identifier is usually used in  the source texts of the lower-level knowledge base. To ensure internationalization, it is recommended that system  identifiers be written in English. The characters used in the system identifier can be letters of the Latin alphabet,  numbers, underscores and dashes. Thus, it is most appropriate to form the system identifier of the sc-element from  the main English one by replacing all characters not included in the alphabet described above with the character \u201c_\u201d.</p> <p>Note</p> <p>All system identifiers must satisfy the regular pattern <code>([a-z]|[A-Z]|'_'|'.'|[0-9])+</code>.</p> <p>Note</p> <p>Now only sc-nodes and sc-links can have system identifiers.</p> <p>There is a quintuple of sc-node with its system identifier.</p> <p></p> <p>Note</p> <p>To include this API provide <code>#include &lt;sc-memory/sc_memory.hpp&gt;</code> in your hpp source.</p>"},{"location":"sc-memory/api/cpp/extended/helper_api/#helpersetsystemidtf","title":"HelperSetSystemIdtf","text":"<p>To set system identifier for some sc-node or sc-link, use the method <code>HelperSetSystemIdtf</code>. If passed system identifier is not valid then the method <code>HelperSetSystemIdtf</code> will throw the exception <code>utils::ExceptionInvalidParams</code> with  description of the error. If passed system identifier is already used for other sc-element then the method will return <code>SC_FALSE</code>.</p> <pre><code>...\nScAddr const &amp; nodeAddr = context.CreateNode(ScType::NodeConst);\n\nbool const &amp; isSystemIdentifierSet \n    = context.HelperSetSystemIdtf(\"my_node\", nodeAddr);\n// The value of `isSystemIdentifierSet` must be equal to `SC_TRUE`.\n...\n</code></pre> <p>If you want to get creating quintuple you can provide variable of type <code>ScSystemIdentifierQuintuple</code> as out parameter.</p> <pre><code>...\nScAddr const &amp; nodeAddr = context.CreateNode(ScType::NodeConst);\n\nScSystemIdentifierQuintuple quintuple;\nbool const &amp; isSystemIdentifierSet \n    = context.HelperSetSystemIdtf(\"my_node\", nodeAddr, quintuple);\nScAddr const &amp; myNodeAddr = quintuple.addr1;\n// The value of `myNodeAddr` must be equal to the value of `nodeAddr`.\nScAddr const &amp; arcToSystemIdtfLinkAddr = quintuple.addr2;\n// The sc-address of common sc-arc between your sc-node and \n// sc-link with system identifier of your sc-node.\nScAddr const &amp; systemIdtfLinkAddr = quintuple.addr3;\n// The sc-address of sc-link with system identifier of your sc-node.\nScAddr const &amp; arcToArcToSystemIdtfLinkAddr = quintuple.addr4;\n// The sc-address of access sc-arc between binary sc-relation \n// with system identifier `nrel_system_identifier` and the common sc-arc\n// between your sc-node and sc-link with system identifier of your sc-node.\nScAddr const &amp; nrelSystemIdtfAddr = quintuple.addr5;\n// The sc-address of binary sc-relation with system identifier \n// `nrel_system_identifier`.\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/helper_api/#helpergetsystemidtf","title":"HelperGetSystemIdtf","text":"<p>To get system identifier of sc-element you can use the method <code>HelperGetSystemIdtf</code>. If sc-element hasn't system  identifier then the method will return empty string.</p> <pre><code>...\nScAddr const &amp; nodeAddr = context.CreateNode(ScType::NodeConst);\n\nbool const &amp; isSystemIdentifierSet \n    = context.HelperSetSystemIdtf(\"my_node\", nodeAddr);\n// The value of `isSystemIdentifierSet` must be equal to `SC_TRUE`.\n\nstd::string const &amp; systemIdtf = context.HelperGetSystemIdtf(nodeAddr);\n// The value of `systemIdtf` must be equal to `\"my_node\"`.\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/helper_api/#helperfindbysystemidtf","title":"HelperFindBySystemIdtf","text":"<p>You can find sc-element by its system identifier. For this use the method <code>HelperFindBySystemIdtf</code>. It will return  <code>SC_TRUE</code> if there is sc-element with provided system identifier, otherwise <code>SC_FALSE</code>.</p> <pre><code>...\nScAddr const &amp; nodeAddr = context.CreateNode(ScType::NodeConst);\n\nbool const &amp; isSystemIdentifierSet \n    = context.HelperSetSystemIdtf(\"my_node\", nodeAddr);\n// The value of `isSystemIdentifierSet` must be equal to `SC_TRUE`.\n\nScAddr resultAddr;\nbool const &amp; isElementWithSystemIdtfFound \n    = context.HelperFindBySystemIdtf(\"my_node\", resultAddr);\n// The value of `isElementWithSystemIdtfFound` must be equal to `SC_TRUE` \n// and the value of `resultAddr` must be equal to the value of `nodeAddr`.\n\n// Or use the another definition of this method.\nresultAddr = context.HelperFindBySystemIdtf(\"my_node\");\n// The value of `resultAddr` must be equal to the value of `nodeAddr`.\n\n// Or use the another definition of this method.\nresultAddr = context.HelperFindBySystemIdtf(\"not_my_node\");\n// The value of `resultAddr` must be invalid.\n...\n</code></pre> <p>If you want to find quintuple sc-element with its system identifier you can provide variable of type  <code>ScSystemIdentifierQuintuple</code> as out parameter.</p> <pre><code>...\nScAddr const &amp; nodeAddr = context.CreateNode(ScType::NodeConst);\n\nbool const &amp; isSystemIdentifierSet \n    = context.HelperSetSystemIdtf(\"my_node\", nodeAddr);\n// The value of `isSystemIdentifierSet` must be equal to `SC_TRUE`.\n\nScSystemIdentifierQuintuple quintuple;\nbool const &amp; isElementWithSystemIdtfFound \n    = context.HelperFindBySystemIdtf(\"my_node\", quintuple);\nScAddr const &amp; myNodeAddr = quintuple.addr1;\n// The value of `myNodeAddr` must be equal to the value of `nodeAddr`.\nScAddr const &amp; arcToSystemIdtfLinkAddr = quintuple.addr2;\n// The sc-address of common sc-arc between your sc-node \n// and sc-link with system identifier of your sc-node.\nScAddr const &amp; systemIdtfLinkAddr = quintuple.addr3;\n// The sc-address of sc-link with system identifier of your sc-node.\nScAddr const &amp; arcToArcToSystemIdtfLinkAddr = quintuple.addr4;\n// The sc-address of access sc-arc between binary sc-relation \n// with system identifier `nrel_system_identifier` and the common sc-arc \n// between your sc-node and sc-link with system identifier of your sc-node.\nScAddr const &amp; nrelSystemIdtfAddr = quintuple.addr5;\n// The sc-address of binary sc-relation with system identifier \n// `nrel_system_identifier`.\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/helper_api/#helperresolvesystemidtf","title":"HelperResolveSystemIdtf","text":"<p>Very often you can need to resolve sc-element by system identifier. Resolve sc-element by system identifier refers to finding for sc-element with providing system identifier and (if such sc-element is not found) creating sc-element with provided system identifier and sc-type.</p> <pre><code>...\nScAddr const &amp; nodeAddr \n    = HelperResolveSystemIdtf(\"my_node\", ScType::NodeConst);\n// If there is no sc-element with system identifier `\"my_node\"` \n// then the method will create sc-element with this system identifier \n// and provided sc-type `ScType::NodeConst`.\n...\n</code></pre> <p>Note</p> <p>Provided sc-type must be a subtype of sc-type of sc-node or sc-type of sc-link.</p> <p>If you want to resolve quintuple sc-element with its system identifier you can provide variable of type <code>ScSystemIdentifierQuintuple</code> as out parameter.</p> <pre><code>...\nScSystemIdentifierQuintuple quintuple;\nbool const &amp; isSystemIdentifierResolved \n    = context.HelperResolveSystemIdtf(\"my_node\", ScType::NodeConst, quintuple);\nScAddr const &amp; myNodeAddr = quintuple.addr1;\n// The sc-address of resolved sc-node by provided system identifier.\nScAddr const &amp; arcToSystemIdtfLinkAddr = quintuple.addr2;\n// The sc-address of common sc-arc between your sc-node and sc-link \n// with system identifier of your sc-node.\nScAddr const &amp; systemIdtfLinkAddr = quintuple.addr3;\n// The sc-address of sc-link with system identifier of your sc-node.\nScAddr const &amp; arcToArcToSystemIdtfLinkAddr = quintuple.addr4;\n// The sc-address of access sc-arc between binary sc-relation\n// with system identifier `nrel_system_identifier` and the common sc-arc \n// between your sc-node and sc-link with system identifier of your sc-node.\nScAddr const &amp; nrelSystemIdtfAddr = quintuple.addr5;\n// The sc-address of binary sc-relation with system identifier \n// `nrel_system_identifier`.\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/helper_api/#frequently-asked-questions","title":"Frequently Asked Questions","text":"<ul> <li>Can I specify empty system identifier for sc-element?</li> </ul>"},{"location":"sc-memory/api/cpp/extended/helper_api/#can-i-specify-empty-system-identifier-for-sc-element","title":"Can I specify empty system identifier for sc-element?","text":"<p>You can not specify empty system identifier for sc-element. All system identifiers must satisfy the regular  pattern <code>([a-z]|[A-Z]|'_'|'.'|[0-9])+</code>.</p>"},{"location":"sc-memory/api/cpp/extended/template_api/","title":"ScTemplate API","text":"<p>Warning</p> <p>This documentation is correct for only versions of sc-machine that &gt;= 0.9.0.</p> <p>Sc-templates is a very powerful mechanism to work with semantic network (graph). You can generate and search any constructions using sc-templates. In the following picture the sc-template and the isomorphic sc-construction are shown.</p> <p></p> <p>Note</p> <p>To include this API provide <code>#include &lt;sc-memory/sc_memory.hpp&gt;</code> in your hpp source.</p>"},{"location":"sc-memory/api/cpp/extended/template_api/#sctemplate","title":"ScTemplate","text":"<p>The class to work with sc-templates in C++ API. Before reading this paragraph you need to read common information about sc-element types.</p> <p>Let use <code>f</code> symbols for constant parameter of sc-template. Let use <code>a</code> symbol for a variable parameter of sc-template.  Then sc-template to search all output sc-connectors from specified sc-element will be a triple:</p> <ul> <li>where the first sc-element is known <code>f</code>;</li> <li>second and the third sc-elements need to be found <code>a</code>.</li> </ul> <p>There are possible 3 types of triple sc-templates:</p> <ul> <li><code>f_a_a</code> - sc-template to find all outgoing sc-connectors from a specified sc-element;</li> <li><code>f_a_f</code> - sc-template to find all sc-connectors between two specified sc-elements;</li> <li><code>a_a_f</code> - sc-template to find all ingoing sc-connectors to a specified sc-element.</li> </ul> <p>And there are possible 7 types of quintuple sc-templates:</p> <ul> <li><code>f_a_a_a_a</code> - sc-template to find all outgoing sc-connectors from a specified sc-element with all attributes of this sc-connectors;</li> <li><code>f_a_f_a_a</code> - sc-template to find all sc-connectors between two specified sc-elements with all attributes of this sc-connectors;</li> <li><code>f_a_a_a_f</code> - sc-template to find all outgoing sc-connectors from a specified sc-element with specified attribute;</li> <li><code>f_a_f_a_f</code> - sc-template to find all sc-connectors between two specified sc-elements with specified attribute;</li> <li><code>a_a_f_a_a</code> - sc-template to find all ingoing sc-connectors to a specified sc-element with all attributes of this sc-connectors;</li> <li><code>a_a_f_a_f</code> - sc-template to find all ingoing sc-connectors to a specified sc-element with specified attribute;</li> <li><code>a_a_a_a_f</code> - sc-template to find all sc-connectors with specified attribute.</li> </ul> <p>Here attribute is sc-element from which the sc-connector is outgoing to the searchable sc-connectors.</p> <p>There are some methods available for <code>ScTemplate</code> class:</p>"},{"location":"sc-memory/api/cpp/extended/template_api/#triple","title":"Triple","text":"<p>It is the method that adds triple sc-construction into sc-template. There are some examples of using this function to produce simple sc-templates:</p> Template Description f_a_a Graphical representation Equal C++ code <pre><code>\nScTemplate templ;\ntempl.Triple(\n  param1,\n  ScType::EdgeAccessVarPosPerm,\n  ScType::NodeVar\n);\n</code></pre> This triple sc-template is used to traverse output edges from specified sc-element.       There <code>param1</code> is a known sc-address of sc-element. It must be a valid (use <code>IsElement</code> method to check). Where <code>_param2</code> and <code>_param3</code> are sc-types for compare by search engine. When search engine will traverse output edges from <code>param1</code>. Construction will be added into traverse result, where output sc-connector from <code>param1</code>, will suitable to specified type <code>_param2</code>, and type of target sc-element of this edge will be sutable for a type <code>_param3</code>.       You can use any sc-type of <code>_param3</code> (including edges) depending on sc-construction you want to find. But <code>_param2</code> should be any sc-type of variable edge.      f_a_f Graphical representation Equal C++ code <pre><code>\nScTemplate templ;\ntempl.Triple(\n  param1,\n  ScType::EdgeAccessVarPosPerm,\n  param3\n);\n</code></pre> This triple sc-template using to find edge between <code>param1</code> and <code>param3</code>.       There are <code>param1</code> and <code>param3</code> a known <code>ScAddr</code> of sc-elements. Edge type <code>_param2</code> should be variable.      a_a_f Graphical representation Equal C++ code <pre><code>\nScTemplate templ;\ntempl.Triple(\n  ScType::NodeVar,\n  ScType::EdgeAccessVarPosPerm,\n  param3\n);\n</code></pre> This triple sc-template using to traverse input edges from specified sc-element.       There <code>param3</code> is a known sc-address of sc-element. You can use any type of <code>_param1</code> (including edges) depending on construction you want to find. But <code>_param2</code> should be any type of variable edge."},{"location":"sc-memory/api/cpp/extended/template_api/#quintuple","title":"Quintuple","text":"<p>It is the method that adds quintuple sc-construction into sc-template. There are some examples of using this  function to produce simple sc-templates:</p> Template Description f_a_a_a_a Graphical representation Equal C++ code <pre><code>\nScTemplate templ;\ntempl.Quintuple(\n  param1,\n  ScType::EdgeAccessVarPosPerm,\n  ScType::NodeVar,\n  ScType::EdgeAccessVarPosPerm,\n  ScType::NodeVar\n);\n</code></pre> f_a_f_a_a Graphical representation Equal C++ code <pre><code>\nScTemplate templ;\ntempl.Quintuple(\n  param1,\n  ScType::EdgeAccessVarPosPerm,\n  param3,\n  ScType::EdgeAccessVarPosPerm,\n  ScType::NodeVar\n);\n</code></pre> f_a_a_a_f Graphical representation Equal C++ code <pre><code>\nScTemplate templ;\ntempl.Quintuple(\n  param1,\n  ScType::EdgeAccessVarPosPerm,\n  ScType::NodeVar,\n  ScType::EdgeAccessVarPosPerm,\n  param5\n);\n</code></pre> f_a_f_a_f Graphical representation Equal C++ code <pre><code>\nScTemplate templ;\ntempl.Quintuple(\n  param1,\n  ScType::EdgeAccessVarPosPerm,\n  param3,\n  ScType::EdgeAccessVarPosPerm,\n  param5\n);\n</code></pre> a_a_f_a_a Graphical representation Equal C++ code <pre><code>\nScTemplate templ;\ntempl.Quintuple(\n  ScType::NodeVar,\n  ScType::EdgeAccessVarPosPerm,\n  param3,\n  ScType::EdgeAccessVarPosPerm,\n  ScType::NodeVar\n);\n</code></pre> a_a_f_a_f Graphical representation Equal C++ code <pre><code>\nScTemplate templ;\ntempl.Quintuple(\n  ScType::NodeVar,\n  ScType::EdgeAccessVarPosPerm,\n  param3,\n  ScType::EdgeAccessVarPosPerm,\n  param5\n);\n</code></pre> a_a_a_a_f Graphical representation Equal C++ code <pre><code>\nScTemplate templ;\ntempl.Quintuple(\n  ScType::NodeVar,\n  ScType::EdgeAccessVarPosPerm,\n  ScType::NodeVar,\n  ScType::EdgeAccessVarPosPerm,\n  param5\n);\n</code></pre> <p>When sc-template search engine works, it tries to traverse graph by simple (triple or quintuple) sc-template in order they specified. For example, we need to check if specified sc-element (<code>_set</code>) is included into <code>concept_set</code> class and <code>concept_binary_relation</code> class:</p> <p></p> <p>There is example code that generates equal sc-template.</p> <pre><code>...\n// Find key concepts that should be used in sc-template.\nScAddr const &amp; conceptSetAddr = context.HelperFindBySystemIdtf(\"concept_set\");\nScAddr const &amp; conceptBinaryRelationAddr \n    = context.HelperFindBySystemIdtf(\"concept_binary_relation\");\n\n// Create sc-template and add triples into this sc-template.\nScTemplate templ;\ntempl.Triple(\n  conceptSetAddr,    // sc-address of concept set node\n  ScType::EdgeAccessVarPosPerm,\n  ScType::NodeVar &gt;&gt; \"_set\"\n);\ntempl.Triple(\n  conceptBinaryRelationAddr,    // sc-address of concept binary relation node\n  ScType::EdgeAccessVarPosPerm,\n  \"_set\"\n);\n..\n</code></pre> <p>In code, you can see a construction <code>ScType::NodeVar &gt;&gt; \"_set\"</code> - this is a naming for a sc-template sc-element. It allows to set alias for a specified sc-element in sc-template, and use it many times in different triples. You can see, that in the second triple we use this alias <code>\"_set\"</code>. That means, that we need to place search result from a first triple into the second. So the second triple is a <code>f_a_f</code> style triple.</p> <p>So if you want to use the same sc-element <code>_x</code> in different triples, and you doesn't know it <code>ScAddr</code>, then just use two main rules:</p> <ul> <li>Set alias of this sc-element in a first occurrence of this sc-element in sc-template triples. You need to use <code>&gt;&gt;</code> operator to   do this (see code below, last sc-element of first triple).</li> <li>When you need to use aliased sc-element in next triples, then just use it alias instead of <code>ScType</code> or <code>ScAddr</code> (see code   below, first sc-element if second triple).</li> </ul> <p>There is the example code with naming.</p> <pre><code>...\nScTemplate templ;\ntempl.Triple(\n  anyAddr, // sc-address of known sc-element\n  ScType::EdgeAccessVarPosPerm,  // type of unknown sc-edge\n  ScType::NodeVar &gt;&gt; \"_x\"  // type and alias for an unknown sc-element\n);\ntempl.Triple(\n  \"_x\",  // say that is the same sc-element as the last on in a previous triple\n  ScType::EdgeAccessVarPosPerm,  // type of unknown sc-edge\n  ScType::NodeVar  // type of unknown sc-node\n);\n...\n</code></pre> <p>Inside a program object of a sc-template all its constructions are represented as triples.</p>"},{"location":"sc-memory/api/cpp/extended/template_api/#hasreplacement","title":"HasReplacement","text":"<p>To check that sc-template has an aliased sc-element you can use the method <code>HasReplacement</code>.</p> <pre><code>...\nScTemplate templ;\ntempl.Triple(\n  anyAddr,\n  ScType::EdgeAccessVarPosPerm,\n  ScType::NodeVar &gt;&gt; \"_x\"\n);\nbool const hasAliasX = templ.HasReplacement(\"_x\");\n// The value of `hasAliasX` be equal to `SC_TRUE`.\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/template_api/#size","title":"Size","text":"<p>To get count of triples in sc-template, use the method <code>Size</code>. It may be useful if your program can choose optimal for  manipulating sc-template.</p> <pre><code>ScTemplate templ;\ntempl.Triple(\n  anyAddr, // sc-address of known sc-element\n  ScType::EdgeAccessVarPosPerm,  // type of unknown sc-edge\n  ScType::NodeVar &gt;&gt; \"_x\"  // type and alias for an unknown sc-element\n);\ntempl.Triple(\n  \"_x\",  // say that is the same sc-element as the last on in a previous triple\n  ScType::EdgeAccessVarPosPerm,  // type of unknown sc-edge\n  ScType::NodeVar  // type of unknown sc-node\n);\n\nsize_t const tripleCount = templ.Size();\n// The triple count must be equal to `2`.\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/template_api/#isempty","title":"IsEmpty","text":"<p>If you need sc-template to be empty you don't have to add any constructions into it. But you should know that result of generation by this sc-template is always <code>SC_TRUE</code> and result of searching by this sc-template is always <code>SC_FALSE</code>. To check that sc-template is empty use the method <code>IsEmpty</code>.</p> <pre><code>...\nScTemplate templ;\nbool const isEmpty = templ.IsEmpty();\n// The value of `isEmpty` be equal to `SC_TRUE`.\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/template_api/#sctemplatebuild","title":"ScTemplateBuild","text":"<p>Also, you can build sc-templates using SCs-code.</p> <pre><code>...\n// Describe your sc-template on SCs-code.\nsc_char const * data = \n  \"_set\"\n  \"  _&lt;- concept_set;\"\n  \"  _&lt;- concept_binary_set;;\";\n\n// Build program object by this sc-template.\nScTemplate templ;\nbool const isTemplateBuilt = context.HelperBuildTemplate(templ, data);\n// The value of `isTemplateBuilt` must be equal to `SC_TRUE`.\n...\n</code></pre> <p>During sc-template building all constants will be resolved by their system identifier (in example: <code>concept_set</code>, <code>concept_binary_set</code>), so in result <code>templ</code> will contain sc-template:</p> <p></p> <p>Or you can it by specifying valid sc-address of some sc-template in sc-memory.</p> <pre><code>...\n// Find by system identifier your sc-template in sc-memory.\nScAddr const &amp; templAddr = context.HelperFindBySystemIdtf(\"my_template\");\n\n// Build program object by this sc-template.\nScTemplate templ;\nbool const isTemplateBuilt = context.HelperBuildTemplate(templ, templAddr);\n// The value of `isTemplateBuilt` must be equal to `SC_TRUE`.\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/template_api/#sctemplateparams","title":"ScTemplateParams","text":"<p>You can replace existing sc-variables in sc-templates by your ones. To provide different replacements for sc-variables  in different cases there is class <code>ScTemplateParams</code>. It stores a map between sc-variables and specified values (replacements).</p> <pre><code>...\nScTemplateParams params;\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/template_api/#add","title":"Add","text":"<p>You can add replacement for sc-variable by specifying system identifier of this sc-variable if sc-template is built from SCs-code.</p> <pre><code>...\n// Describe your sc-template on SCs-code.\nsc_char const * data = \n  \"_set\"\n  \"  _&lt;- concept_set;\"\n  \"  _&lt;- concept_binary_set;;\";\n\n// Create replacement in sc-memory.\nScAddr const &amp; setAddr = context.CreateNode(ScType::NodeConst);\n// Also you can find some replacement from sc-memory.\n\n// Define replacements for sc-variables in sc-template.\nScTemplateParams params;\nparams.Add(\"_set\", setAddr);\n\n// Build program object by this sc-template, specifying replacements.\nScTemplate templ;\ncontext.HelperBuildTemplate(templ, data, params);\n...\n</code></pre> <p>Or you can add replacement for sc-variable by specifying sc-address of this sc-variable if sc-template is built from  sc-address of sc-structure in sc-memory.</p> <pre><code>...\n// Find by system identifier your sc-template in sc-memory.\nScAddr const &amp; templAddr = context.HelperFindBySystemIdtf(\"my_template\");\n\n// Find by system identifier sc-address of sc-variable in your sc-template.\nScAddr const &amp; setVarAddr = context.HelperFindBySystemIdtf(\"_set\");\n\n// Create replacement in sc-memory.\nScAddr const &amp; setAddr = context.CreateNode(ScType::NodeConst);\n// Also you can find some replacement from sc-memory.\n\n// Define replacements for sc-variables in sc-template.\nScTemplateParams params;\nparams.Add(setVarAddr, setAddr);\n\n// Build program object by this sc-template, specifying replacements.\nScTemplate templ;\ncontext.HelperBuildTemplate(templ, templAddr, params);\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/template_api/#get","title":"Get","text":"<p>Sometimes you need to check if there is replacement in params yet. You can do it using the method <code>Get</code>. It works with system identifiers and sc-addresses of sc-variables also.</p> <pre><code>...\n// Create replacement in sc-memory.\nScAddr const &amp; setAddr = context.CreateNode(ScType::NodeConst);\n// Also you can find some replacement from sc-memory.\n\n// Define replacements for sc-variables in sc-template.\nScTemplateParams params;\nparams.Add(\"_set\", setAddr);\n\nScAddr const &amp; replAddr = params.Get(\"_set\");\n// The value of `replAddr` be equal to value of `setAddr`.\n...\n</code></pre> <pre><code>...\n// Find by system identifier sc-address of sc-variable in your sc-template.\nScAddr const &amp; setVarAddr = context.HelperFindBySystemIdtf(\"_set\");\n\n// Create replacement in sc-memory.\nScAddr const &amp; setAddr = context.CreateNode(ScType::NodeConst);\n// Also you can find some replacement from sc-memory.\n\n// Define replacements for sc-variables in sc-template.\nScTemplateParams params;\nparams.Add(setVarAddr, setAddr);\n\nScAddr const &amp; replAddr = params.Get(setVarAddr);\n// The value of `replAddr` be equal to value of `setAddr`.\n...\n</code></pre> <p>Note</p> <p>If there are no replacements by specified system identifier or sc-address of sc-variable of sc-template then the  method <code>Get</code> will return empty sc-address.</p>"},{"location":"sc-memory/api/cpp/extended/template_api/#isempty_1","title":"IsEmpty","text":"<p>To check that replacements map is empty use the method <code>IsEmpty</code>.</p> <pre><code>...\nScTemplateParams params;\nbool const isEmpty = params.IsEmpty();\n// The value of `isEmpty` be equal to `SC_TRUE`.\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/template_api/#helpergentemplate","title":"HelperGenTemplate","text":"<p>Use sc-template to generate graphs in sc-memory and get replacements from result.</p> <pre><code>...\n// Specify sc-template for searching sc-constructions in sc-memory.\n// You can use `ScTemplate` methods or method ScTemplateBuild to translate \n// sc-template from SCs-code or sc-memory into program representation.\nScTemplateResultItem result;\nbool const isGeneratedByTemplate = context.HelperGenTemplate(templ, result);\n// Sc-elements sc-addresses of generated sc-construction may be gotten from \n// `result`.\n...\n</code></pre> <p>Note</p> <p>Remember, that sc-template must contain only valid sc-address of sc-elements and all sc-connectors in it must be sc-variables. Otherwise, this method can throw <code>utils::ExceptionInvalidParams</code> with description of this error.</p>"},{"location":"sc-memory/api/cpp/extended/template_api/#sctemplateresultitem","title":"ScTemplateResultItem","text":"<p>It is a class that stores information about sc-construction.</p>"},{"location":"sc-memory/api/cpp/extended/template_api/#safe-get","title":"Safe Get","text":"<p>You can get sc-addresses of sc-elements of generated sc-construction by system identifier or sc-address of sc-variable  in sc-template. To do it safely (without throwing exceptions if there are no replacements by specified system identifier  or sc-address of sc-variable of sc-template) use the methods <code>Get</code> and provide result of replacement as out parameter in this method.</p> <pre><code>...\nScTemplate templ;\ntempl.Triple(\n  conceptSetAddr,\n  ScType::EdgeAccessVarPosPerm,\n  ScType::NodeVar &gt;&gt; \"_x\"\n);\n\nScTemplateResultItem result;\nbool const isGeneratedByTemplate = context.HelperGenTemplate(templ, result);\n\nScAddr setAddr;\nbool replExist = result.Get(\"_x\", setAddr);\n// The value of `replExist` be equal to `SC_TRUE`.\n\nbool replExist = result.Get(\"_y\", setAddr);\n// The value of `replExist` be equal to `SC_FALSE`.\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/template_api/#get_1","title":"Get","text":"<p>If you want to catch exceptions, if there are no replacements by specified system identifier or sc-address of sc-variable  of sc-template, use the method <code>Get</code> and get replacement as result of this method. Then this method will throw  <code>utils::ExceptionInvalidParams</code> with description of error.</p> <pre><code>...\nScTemplate templ;\ntempl.Triple(\n  conceptSetAddr,\n  ScType::EdgeAccessVarPosPerm,\n  ScType::NodeVar &gt;&gt; \"_x\"\n);\n\nScTemplateResultItem result;\nbool const isGeneratedByTemplate = context.HelperGenTemplate(templ, result);\n\nScAddr setAddr = result.Get(\"_x\");\n\nsetAddr = result.Get(\"_y\", setAddr);\n// It will throw the exception `utils::ExceptionInvalidParams`.\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/template_api/#has","title":"Has","text":"<p>To check that there is replacement by specified system identifier or sc-address of sc-variable of sc-template use the method <code>Has</code>.</p> <pre><code>...\nScTemplate templ;\ntempl.Triple(\n  conceptSetAddr,\n  ScType::EdgeAccessVarPosPerm,\n  ScType::NodeVar &gt;&gt; \"_x\"\n);\n\nScTemplateResultItem result;\nbool const isGeneratedByTemplate = context.HelperGenTemplate(templ, result);\n\nbool const replExist = result.Has(\"_x\");\n// The value of `replExist` be equal to `SC_TRUE`.\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/template_api/#operator","title":"operator[]","text":"<p>To get all replacements in result you can use the <code>operator[]</code>. It returns replacement by index of sc-variable in  sc-template. If there is no sc-variable with specified index this method will throw the exception  <code>utils::ExceptionInvalidParams</code> with description of the error.</p> <pre><code>...\nScTemplate templ;\ntempl.Triple(\n  conceptSetAddr,\n  ScType::EdgeAccessVarPosPerm,\n  ScType::NodeVar &gt;&gt; \"_x\"\n);\n\nScTemplateResultItem result;\nbool const isGeneratedByTemplate = context.HelperGenTemplate(templ, result);\n\nScAddr const &amp; setAddr = result[2];\n// It is equal to `result.Get(\"_x\")`.\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/template_api/#size_1","title":"Size","text":"<p>If you want to iterate all replacement in the result you need to know size of this result.</p> <pre><code>...\nScTemplate templ;\ntempl.Triple(\n  conceptSetAddr,\n  ScType::EdgeAccessVarPosPerm,\n  ScType::NodeVar &gt;&gt; \"_x\"\n);\n\nScTemplateResultItem result;\nbool const isGeneratedByTemplate = context.HelperGenTemplate(templ, result);\n\n// Iterate by all replacements in result.\nfor (size_t i = 0; i &lt; result.Size(); ++i)\n{\n  ScAddr const &amp; addr = result[i];\n  // Implement your code to handle replacements.\n}\n...\n</code></pre> <p>Note</p> <p>The method <code>Size</code> returns summary count of indexes of replacements in each triple in sc-template. If there are  <code>2</code> triples in sc-template, then there are <code>2 * 3 = 6</code> different indexes of replacements in sc-template.</p>"},{"location":"sc-memory/api/cpp/extended/template_api/#helpersearchtemplate","title":"HelperSearchTemplate","text":"<p>You can search sc-construction in sc-memory by sc-templates. This search refers to isomorphic search by graph-template. Search algorithm trying to find all possible variants of specified construction. It uses any constants (available sc-addresses from parameters to find equal sc-constructions in sc-memory).</p> <pre><code>...\n// Specify sc-template for searching sc-constructions in sc-memory.\n// You can use `ScTemplate` methods or method ScTemplateBuild to translate \n// sc-template from SCs-code or sc-memory into program representation.\nScTemplateSearchResult result;\nbool const isFoundByTemplate = context.HelperSearchTemplate(templ, result);\n// Program representation of sc-constructions in `ScTemplateResultItem` \n// may be gotten from `result`.\n...\n</code></pre> <p>Note</p> <p>Remember, that sc-template must contain only valid sc-address of sc-elements and all sc-connectors in it must be sc-variables. Otherwise, this method can throw <code>utils::ExceptionInvalidParams</code> with description of this error.</p>"},{"location":"sc-memory/api/cpp/extended/template_api/#sctemplatesearchresult","title":"ScTemplateSearchResult","text":"<p>It is a class that stores in information about sc-constructions represented in <code>ScTemplateResultItem</code>. An object of class <code>ScTemplateSearchResult</code> can be referred to a vector of objects of class <code>ScTemplateResultItem</code>.</p>"},{"location":"sc-memory/api/cpp/extended/template_api/#safe-get_1","title":"Safe Get","text":"<p>To get object of class <code>ScTemplateResultItem</code> you can use the method <code>Get</code>. If you want to get objects safely, use the method <code>Get</code> and provide <code>ScTemplateResultItem</code> as out parameter in this method.</p> <pre><code>...\nScTemplate templ;\ntempl.Triple(\n  conceptSetAddr,\n  ScType::EdgeAccessVarPosPerm,\n  ScType::NodeVar &gt;&gt; \"_x\"\n);\n// There is one sc-construction that is isomorphic this sc-template.\n\nScTemplateSearchResult result;\nbool const isFoundByTemplate = context.HelperSearchTemplate(templ, result);\n\nScTemplateResultItem item;\nbool constrExist = result.Get(0, item);\n// The value of `constrExist` be equal to `SC_TRUE`.\n\nconstrExist = result.Get(1, item);\n// The value of `constrExist` be equal to `SC_FALSE` and item is not valid.\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/template_api/#get_2","title":"Get","text":"<p>If you want to catch exceptions use the method <code>Get</code> and get result as return value. If there is no sc-construction with  specified index this method will throw the exception utils::ExceptionInvalidParams with description of the error.</p> <pre><code>...\nScTemplate templ;\ntempl.Triple(\n  conceptSetAddr,\n  ScType::EdgeAccessVarPosPerm,\n  ScType::NodeVar &gt;&gt; \"_x\"\n);\n// There is one sc-construction that is isomorphic this sc-template.\n\nScTemplateSearchResult result;\nbool const isFoundByTemplate = context.HelperSearchTemplate(templ, result);\n\nScTemplateResultItem item = result.Get(0);\n// It is a valid item.\n\nitem = result.Get(1);\n// It throws `utils::ExceptionInvalidParams`.\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/template_api/#operator_1","title":"operator[]","text":"<p>Also, you can use the method <code>operator[]</code> to do this. If there is no sc-construction with specified index this method  will throw the exception utils::ExceptionInvalidParams with description of the error.</p> <pre><code>...\nScTemplate templ;\ntempl.Triple(\n  conceptSetAddr,\n  ScType::EdgeAccessVarPosPerm,\n  ScType::NodeVar &gt;&gt; \"_x\"\n);\n// There is one sc-construction that is isomorphic this sc-template.\n\nScTemplateSearchResult result;\nbool const isFoundByTemplate = context.HelperSearchTemplate(templ, result);\n\nScTemplateResultItem item = result[0];\n// It is a valid item.\n\nitem = result[1];\n// It throws `utils::ExceptionInvalidParams`.\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/template_api/#size_2","title":"Size","text":"<p>To get count of found sc-constructions by sc-template you can use the method <code>Size</code>.</p> <pre><code>...\nScTemplate templ;\ntempl.Triple(\n  conceptSetAddr,\n  ScType::EdgeAccessVarPosPerm,\n  ScType::NodeVar &gt;&gt; \"_x\"\n);\n// There is one sc-construction that is isomorphic this sc-template.\n\nScTemplateSearchResult result;\nbool const isFoundByTemplate = context.HelperSearchTemplate(templ, result);\n\nsize_t const count = result.Size();\n// The value of `count` be equal to `1`.\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/template_api/#isempty_2","title":"IsEmpty","text":"<p>To check if found result is empty use the method <code>IsEmpty</code>.</p> <pre><code>...\nScTemplate templ;\ntempl.Triple(\n  conceptSetAddr,\n  ScType::EdgeAccessVarPosPerm,\n  ScType::NodeVar &gt;&gt; \"_x\"\n);\n// There is one sc-construction that is isomorphic this sc-template.\n\nScTemplateSearchResult result;\nbool const isFoundByTemplate = context.HelperSearchTemplate(templ, result);\n\nbool const count = result.IsEmpty();\n// The value of `count` be equal to `SC_FALSE`.\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/template_api/#clear","title":"Clear","text":"<p>To clear all information about found sc-constructions use the method <code>Clear</code>.</p> <pre><code>...\nScTemplate templ;\ntempl.Triple(\n  conceptSetAddr,\n  ScType::EdgeAccessVarPosPerm,\n  ScType::NodeVar &gt;&gt; \"_x\"\n);\n// There is one sc-construction that is isomorphic this sc-template.\n\nScTemplateSearchResult result;\nbool const isFoundByTemplate = context.HelperSearchTemplate(templ, result);\n\nresult.Clear();\n// After that `result` does not contain any information about sc-constructions.\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/template_api/#foreach","title":"ForEach","text":"<p>To iterate all program objects of found sc-constructions by sc-template you can use for-each cycle.</p> <pre><code>...\nScTemplate templ;\ntempl.Triple(\n  conceptSetAddr,\n  ScType::EdgeAccessVarPosPerm,\n  ScType::NodeVar &gt;&gt; \"_x\"\n);\n// There is one sc-construction that is isomorphic this sc-template.\n\nScTemplateSearchResult result;\nbool const isFoundByTemplate = context.HelperSearchTemplate(templ, result);\n\nfor (size_t i = 0; i &lt; result.Size(); ++i)\n{\n  ScTemplateResultItem const &amp; item = result.Get(i);\n  // Implement logic to handle found sc-constructions.\n}\n...\n</code></pre> <p>Or you can use the method <code>ForEach</code> to do this.</p> <pre><code>...\nScTemplate templ;\ntempl.Triple(\n  conceptSetAddr,\n  ScType::EdgeAccessVarPosPerm,\n  ScType::NodeVar &gt;&gt; \"_x\"\n);\n// There is one sc-construction that is isomorphic this sc-template.\n\nScTemplateSearchResult result;\nbool const isFoundByTemplate = context.HelperSearchTemplate(templ, result);\n\nresult.ForEach([](ScTemplateResultItem const &amp; item) {\n  // Implement logic to handle found sc-constructions.\n});\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/template_api/#helpersmartsearchtemplate","title":"HelperSmartSearchTemplate","text":"<p>This method searches constructions by isomorphic sc-template and pass found sc-constructions to <code>callback</code>  lambda-function. Lambda-function <code>callback</code> must return a request command value to manage sc-template search:</p> <ul> <li>ScTemplateSearchRequest::CONTINUE,</li> <li>ScTemplateSearchRequest::STOP,</li> <li>ScTemplateSearchRequest::ERROR.</li> </ul> <p>When ScTemplateSearchRequest::CONTINUE returns, sc-template search will be continued. If ScTemplateSearchRequest::STOP  or ScTemplateSearchRequest::ERROR returns, then sc-template search stops. If sc-template search stopped by  ScTemplateSearchRequest::ERROR, then HelperSmartSearchTemplate thrown utils::ExceptionInvalidState. If <code>filterCallback</code>  passed, then all found sc-constructions triples are filtered by <code>filterCallback</code> condition.</p> <pre><code>...\nScAddr const &amp; structureAddr = context.HelperFindBySystemIdtf(\"my_structure\");\nScAddr const &amp; setAddr = context.HelperFindBySystemIdtf(\"my_set\");\nScAddr const &amp; classAddr = context.HelperFindBySystemIdtf(\"my_class\");\n\nScTemplate templ;\ntempl.Triple(\n  classAddr,\n  ScType::EdgeAccessVarPosPerm &gt;&gt; \"_edge\",\n  ScType::Unknown &gt;&gt; \"_addr2\"\n);\nm_context-&gt;HelperSmartSearchTemplate(templ, [&amp;context](\n    ScTemplateSearchResultItem const &amp; item) -&gt; ScTemplateSearchRequest \n{\n  ScAddr const &amp; edgeAddr = item[\"_edge\"];\n  if (context-&gt;HelperCheckEdge(\n      structureAddr, edgeAddr, ScType::EdgeAccessConstPosPerm))   \n    return ScTemplateSearchRequest::CONTINUE;\n\n  if (context.CreateEdge(\n      ScType::EdgeAccessConstPosTemp, setAddr, item[\"_addr2\"]))\n    return ScTemplateSearchRequest::STOP;\n\n  return ScTemplateSearchRequest::ERROR;\n});\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/template_api/#frequently-asked-questions","title":"Frequently Asked Questions","text":"<ul> <li>What's the best way to describe sc-templates for search? By sc-template C++ API or on the SC-code?</li> <li>Which is better: searching by sc-template or by iterator?</li> </ul>"},{"location":"sc-memory/api/cpp/extended/template_api/#what-is-the-best-way-to-describe-sc-templates-for-search-by-sc-template-c-api-or-on-the-sc-code","title":"What is the best way to describe sc-templates for search? By sc-template C++ API or on the SC-code?","text":"<p>The description of sc-templates in the knowledge base encourages the use of reflection for them. The sc-templates  described in the knowledge base can be easily expanded and improved. However, sc-templates presented through the API  do not require preprocessing (translation from the knowledge base), so the speed of the program used by such  sc-templates may be higher if the sc-templates have significant size.</p>"},{"location":"sc-memory/api/cpp/extended/template_api/#which-is-better-searching-by-sc-template-or-by-iterator","title":"Which is better: searching by sc-template or by iterator?","text":"<p>In all cases sc-iterator is faster the searching by sc-template. If you want to search large sc-constructions, then don't search they by one large sc-template, divide it into certain sc-templates or use sc-iterators instead of sc-template.</p>"},{"location":"sc-tools/cpp_meta/","title":"Meta Programming","text":"<p>There is a code generator that allows to create some common code by using metadata. It runs before code compilation and generate files with a name <code>&lt;header_name&gt;.generated.&lt;header_extension&gt;</code>. For example if you run it for a file <code>text.h</code> it would produce a file <code>text.generated.h</code></p> <p>To make a metadata for you code you can use this set of macros:</p> <ul> <li><code>SC_CLASS</code> allows you to specify metadata for a class;</li> <li><code>SC_GENERATED_BODY</code> is a macro that need to be used after SC_CLASS, because it would be replaced in during  compilation time with generated declaration for this class;</li> <li><code>SC_PROPERTY</code> allows to specify metadata for members of a class (including static members).</li> </ul> <p>You should to specify SC_CLASS and SC_GENERATED_BODY for all child classes of ScObject.</p>"},{"location":"sc-tools/cpp_meta/#syntax","title":"Syntax","text":"<p>There is a syntax rule that used for a metadata specification: <pre><code>[&lt;PropertyName&gt; [ (&lt;PropertyValue&gt;, &lt;PropertyValue&gt;, ...) ] ], ...\n</code></pre></p> <p>For example:</p> <p><pre><code>SC_CLASS(Agent, CmdClass(\"command_update_power_usage\"))\n</code></pre> <pre><code>SC_CLASS(CmdClass(\"command_generate_text_from_template\"), Agent)\n</code></pre> <pre><code>SC_PROPERTY(Keynode(\"nrel_real_energy_usage\"), ForceCreate)\n</code></pre> <pre><code>SC_CLASS(Agent, Event(ActionManager::msActionPeriodical, SC_EVENT_ADD_OUTPUT_ARC))\n</code></pre></p> <p>You should to use SC_CLASS and SC_GENERATED_BODY in class declaration: <pre><code>class AWhoAreYouAgent : public ScAgentAction\n{\n SC_CLASS(Agent, CmdClass(\"command_who_are_you\"))\n SC_GENERATED_BODY()\n}\n</code></pre></p>"},{"location":"sc-tools/cpp_meta/#classes","title":"Classes","text":"<p>Table of available properties of class metadata (SC_CLASS):</p> Property Description Agent Parent class: ScAgent and all childs       You should always use it for all ScAgent child classes      CmdClass Determine system identifier of command class that implemented by sc-agent.     Parent class: ScAgentAction     Arguments: <ul> <li>System identifier of command class.</li> </ul> <pre><code>\nclass AAddContentAgent : public ScAgentAction\n{\n SC_CLASS(Agent, CmdClass(\"command_add_content\"))\n SC_GENERATED_BODY()\n}\n    </code></pre> Event Specify condition to start sc-agent implementation. Parent class: ScAgent       Arguments: <ul> <li>ScAddr of element which will be used to subscribe for an event;</li> <li>ScEventType type of event to subscribe.</li> </ul>       Another words, we specify sc-element and event on it, that runs implementation of sc-agent. Possible event types:       <ul> <li>SC_EVENT_ADD_OUTPUT_ARC</li> <li>SC_EVENT_ADD_INPUT_ARC</li> <li>SC_EVENT_REMOVE_OUTPUT_ARC</li> <li>SC_EVENT_REMOVE_INPUT_ARC</li> <li>SC_EVENT_REMOVE_ELEMENT</li> <li>SC_EVENT_CONTENT_CHANGED</li> </ul> <pre><code>\nclass ANewPeriodicalActionAgent : public ScAgent\n{\n  SC_CLASS(Agent, Event(msActionPeriodical, SC_EVENT_ADD_OUTPUT_ARC))\n  SC_GENERATED_BODY()\n}\n      </code></pre> LoadOrder Specify order (priority) of module loading. Can be used just in ScModule child classes.       Parent class: ScModule       Arguments: <ul> <li>Priority as unsigned int number</li> </ul>       System loads modules by ascending order. If two module has an equal load order, then they can load in any order (relative to each other).        <pre><code>\nclass nlModule : public ScModule\n{\n  SC_CLASS(LoadOrder(11))\n  SC_GENERATED_BODY()\n\n  sc_result initializeImpl();\n  sc_result shutdownImpl();\n}\n      </code></pre>"},{"location":"sc-tools/cpp_meta/#members","title":"Members","text":"<p>Table of available properties of class members metadata <code>SC_PROPERTY</code>:</p> Property Description Keynode Arguments: <ul> <li>String with system identifier of sc-element.</li> </ul>       Specify that this member is a keynode. After module starts, this member will contains ScAddr of specified sc-element or invalid ScAddr if sc-element not found. Just add ForceCreate to create sc-element in case when it didn't found.       You can use this property just for members that has ScAddr type.        <pre><code>\nSC_PROPERTY(Keynode(\"device\"), ForceCreate)\nstatic ScAddr m_device;\n      </code></pre> Template Arguments: <ul> <li>String system identifier of template sc-structure in sc-memory</li> </ul>       Specify that this member is a template. After module starts, this template will be parsed from sc-memory. So you will be able use it to search/generate constructions.       You can use this property just for members that has ScTemplate type.        <pre><code>\nSC_PROPERTY(Template(\"test_template\"))\nScTemplate m_testTemplate;\n      </code></pre> ForceCreate Arguments: <ul> <li>[optional] type of sc-element. Any value from `ScType::Node...`</li> </ul> Used just with Keynode property. Using of this property force sc-element creation, if it didn't find by system identifier.        <pre><code>\nSC_PROPERTY(Keynode(\"device\"), ForceCreate(ScType::NodeConstClass))\nstatic ScAddr m_device;\n\nSC_PROPERTY(Keynode(\"device\"), ForceCreate) // default value ScType::Node\nstatic ScAddr m_node;\n      </code></pre>"},{"location":"sc-tools/cpp_meta/#frequently-asked-questions","title":"Frequently Asked Questions","text":"<ul> <li>How to include one <code>MyObject</code> into <code>OtherObject</code>?</li> </ul>"},{"location":"sc-tools/cpp_meta/#how-to-include-one-myobject-into-otherobject","title":"How to include one <code>MyObject</code> into <code>OtherObject</code>?","text":"<pre><code>/* In CPP file you should include header file for object, that implemented in this file\n * For example in file MyObject.cpp we should make order\n */\n#include \"otherObject.hpp\"\n#include \"otherObject2.hpp\"\n...\n\n#include \"myObject.hpp\"\n\n// other includes (that doesn't contain ScObject derived classes)\n...\n\n// Implementation\n...\n</code></pre>"},{"location":"sc-tools/kb_repo_file/","title":"Knowledge Base repo file","text":""},{"location":"sc-tools/kb_repo_file/#knowledge-base-repository-file-repopath","title":"Knowledge base repository file - repo.path","text":"<p>For more complex KB setups (with several folders across the filesystem, for example), we've created an internal file format called <code>repo.path</code>. It allows you to specify all the folders that should be built into the KB or exclude some files or subfolders.</p>"},{"location":"sc-tools/kb_repo_file/#example","title":"Example","text":"<pre><code># Comments should start with hashtag as a first character in the line\n# Here you can specify path to one or several kb folders\n# Paths can be relative\n../ims.ostis.kb\n/full/path/to/kb\n../custom_kb\n# you can also exclude files or folders by adding a \"!\" symbol at the beginning of the line\n!../ims.ostis.kb/ims/ostis_tech\n!../custom_kb/test.scs\n</code></pre>"},{"location":"sc-tools/sc_builder/","title":"sc-builder","text":"<p>Sc-builder tool allows to build knowledge base from sources. You can find it in a <code>bin</code> directory. There are options of this tool:</p> <pre>\n./bin/sc-builder --help\n\nSc-builder usage:\n\n  --config|-c arg           Path to configuration .ini file\n  --input_path|-i arg       Path to directory with sources\n  --output_path|-o arg      Path to output directory (repository)\n  --auto_formats|-f         Enable automatic formats info generation\n  --clear                   Flag to clear sc-memory on start\n  --help                    Display this message\n</pre> <p>Example of usage:</p> <pre><code>cd sc-machine\n./bin/sc-builder -c ./sc-machine.ini -i ./kb -o ./kb.bin -f --clear\n</code></pre>"},{"location":"sc-tools/sc_machine/","title":"sc-machine","text":"<p>Warning</p> <p>This documentation is correct for only versions of sc-machine that &gt;= 0.10.0.</p> <p>Sc-machine is a sc-memory with opportunity to add modules consistent with the general sc-machine interface. All such  modules are named extensions, must be shared libraries (with file extension <code>.so</code> or <code>.dylib</code>) and stored in common directory  (by default it is <code>./bin/extensions</code>). By default, sc-machine contains sc-server that allows to communicate with  sc-memory through network. You can find <code>sc-machine</code> in a <code>bin</code> directory.</p> <p>There are options of sc-machine:</p> <pre>\n./bin/sc-machine --help\n\nSc-machine usage:\n\n  --config|-c               Path to configuration file\n  --extensions_path|-e      Path to directory with sc-memory extensions\n  --repo_path|-r            Path to kb.bin folder\n  --clear                   Flag to clear sc-memory state on initialize\n  --verbose|-v              Flag to don't save sc-memory state on shutdown\n  --test|-t                 Flag to test sc-machine (sc-machine with this option runs and stops)\n  --help                    Display this message\n</pre> <p>Example of usage:</p> <pre><code>cd sc-machine\n./bin/sc-machine -c ./sc-machine.ini\n</code></pre>"},{"location":"sc-tools/sc_server/","title":"sc-server","text":"<p>Sc-server allows to communicate with sc-memory through network. You can find it in the <code>bin</code> directory. There are options of this tool:</p> <p>Warning</p> <p>Now sc-server is an extension and all extensions are loaded by executable <code>sc-machine</code>. The executable <code>sc-server</code> is deprecated in sc-machine 0.10.0. It will be removed in sc-machine 0.11.0. Use executable <code>sc-machine</code>  instead.</p> <pre>\n./bin/sc-server --help\n\nSc-server usage:\n\n  --config|-c               Path to configuration file\n  --host|-h                 sc-server host name, ip-address\n  --port|-p                 sc-server port\n  --extensions_path|-e      Path to directory with sc-memory extensions\n  --repo_path|-r            Path to kb.bin folder\n  --clear                   Flag to clear sc-memory state on initialize\n  --verbose|-v              Flag to don't save sc-memory state on shutdown\n  --test|-t                 Flag to test sc-server (sc-server with this option runs and stops)\n  --help                    Display this message\n</pre> <p>Example of usage:</p> <pre><code>cd sc-machine\n./bin/sc-server -c ./sc-machine.ini\n</code></pre>"},{"location":"scs/sc_element_types/","title":"Sc-element types","text":"<p>Warning</p> <p>This documentation is correct for only versions of sc-machine that &gt;= 0.9.0.</p> Graphical (SCg) C C++ SCs 10-based NS 16-based NS sc_type_node ScType::Node sc_node 1 0x1 sc_type_const ScType::Const 32 0x20 sc_type_var ScType::Var 64 0x40 sc_type_node | sc_type_const ScType::NodeConst 33 0x21 sc_type_node | sc_type_var ScType::NodeVar 65 0x41 sc_type_node | sc_type_node_tuple ScType::NodeTuple sc_node_tuple 129 0x81 sc_type_node | sc_type_const | sc_type_node_tuple ScType::NodeConstTuple sc_node_tuple  sc_node_not_binary_tuple 161 0xA1 sc_type_node | sc_type_var | sc_type_node_tuple ScType::NodeVarTuple 193 0xC1 sc_type_node | sc_type_node_struct ScType::NodeStruct sc_node_struct 257 0x101 sc_type_node | sc_type_const | sc_type_node_struct ScType::NodeConstStruct sc_node_struct 289 0x121 sc_type_node | sc_type_var | sc_type_node_struct ScType::NodeVarStruct 321 0x141 sc_type_node | sc_type_node_role ScType::NodeRole sc_node_role_relation 513 0x201 sc_type_node | sc_type_const | sc_type_node_role ScType::NodeConstRole sc_node_role_relation 545 0x221 sc_type_node | sc_type_var | sc_type_node_role ScType::NodeVarRole 577 0x241 sc_type_node | sc_type_node_norole ScType::NodeNorole sc_node_norole_relation 1025 0x401 sc_type_node | sc_type_const | sc_type_node_norole ScType::NodeConstNorole sc_node_norole_relation 1057 0x421 sc_type_node | sc_type_var | sc_type_node_norole ScType::NodeVarNorole 1089 0x441 sc_type_node | sc_type_node_class ScType::NodeClass sc_node_class 2049 0x801 sc_type_node | sc_type_const | sc_type_node_class ScType::NodeConstClass sc_node_class  sc_node_not_relation 2089 0x821 sc_type_node | sc_type_var | sc_type_node_class ScType::NodeVarClass 2113 0x841 sc_type_node | sc_type_node_material ScType::NodeMaterial sc_node_material 8191 0x2001 sc_type_node | sc_type_const | sc_type_node_material ScType::NodeConstMaterial sc_node_material 8225 0x2021 sc_type_node | sc_type_var | sc_type_node_material ScType::NodeVarMaterial 8257 0x2041 sc_type_link_const ScType::Link sc_link 34 0x22 sc_type_link_var ScType::LinkVar sc_link_var 66 0x42 sc_type_edge_common ScType::EdgeUCommon sc_edgesc_edge_ucommon&lt;&gt; 4 0x04 sc_type_arc_common ScType::EdgeDCommon sc_arc_common  sc_edge_common  &lt;  &gt; 8 0x08 sc_type_edge_common | sc_type_const ScType::EdgeUCommonConst &lt;=&gt; 36 0x24 sc_type_edge_common | sc_type_var ScType::EdgeUCommonVar _&lt;=&gt; 68 0x44 sc_type_arc_common | sc_type_const ScType::EdgeDCommonConst =&gt;  &lt;= 40 0x28 sc_type_arc_common | sc_type_var ScType::EdgeDCommonVar _&lt;=  &lt;=_  _=&gt; 72 0x48 sc_type_arc_access ScType::EdgeAccess sc_arc_access  sc_edge_access  ..&gt;  &lt;..  16 0x10 sc_type_arc_access | sc_type_const | sc_type_arc_pos | sc_type_arc_perm ScType::EdgeAccessConstPosPerm sc_arc_main  sc_edge_main  &lt;-  -&gt; 2224 0x8B0 sc_type_arc_access | sc_type_var | sc_type_arc_pos | sc_type_arc_perm ScType::EdgeAccessVarPosPerm _&lt;-  _-&gt;  &lt;-_ 2256 0x8D0 sc_type_arc_access | sc_type_const | sc_type_arc_neg | sc_type_arc_perm ScType::EdgeAccessConstNegPerm &lt;|-  -|&gt; 2352 0x930 sc_type_arc_access | sc_type_var | sc_type_arc_neg | sc_type_arc_perm ScType::EdgeAccessVarNegPerm _&lt;|-  _-|&gt;  &lt;|-_ 2384 0x950 sc_type_arc_access | sc_type_const | sc_type_arc_fuz | sc_type_arc_perm ScType::EdgeAccessConstFuzPerm &lt;/-  -/&gt; 2608 0xA30 sc_type_arc_access | sc_type_var | sc_type_arc_fuz | sc_type_arc_perm ScType::EdgeAccessVarFuzPerm _&lt;/-_-/&gt;&lt;/-_ 2640 0xA50 sc_type_arc_access | sc_type_const | sc_type_arc_pos | sc_type_arc_temp ScType::EdgeAccessConstPosTemp &lt;~  ~&gt; 1200 0x4B0 sc_type_arc_access | sc_type_var | sc_type_arc_pos | sc_type_arc_temp ScType::EdgeAccessVarPosPerm _&lt;~  _~&gt;  &lt;~_ 1232 0x4D0 sc_type_arc_access | sc_type_const | sc_type_arc_neg | sc_type_arc_temp ScType::EdgeAccessConstNegTemp &lt;|~  ~|&gt; 1328 0x530 sc_type_arc_access | sc_type_var | sc_type_arc_neg | sc_type_arc_temp ScType::EdgeAccessVarNegPerm _&lt;|~  _~|&gt;  &lt;|~_ 1360 0x550 sc_type_arc_access | sc_type_const | sc_type_arc_fuz | sc_type_arc_temp ScType::EdgeAccessConstFuzTemp &lt;/~  ~/&gt; 1584 0x630 sc_type_arc_access | sc_type_var | sc_type_arc_fuz | sc_type_arc_temp ScType::EdgeAccessVarFuzPerm _&lt;/~  _~/&gt;  &lt;/~_ 1616 0x650"},{"location":"scs/scs/","title":"SCs-code","text":"<p>Warning</p> <p>This documentation is correct for only versions of sc-machine that &gt;= 0.9.0.</p>"},{"location":"scs/scs/#common","title":"Common","text":"<p>SCs-code - is a text representation of SC-code. Whole text consist of sentences, that separated by <code>;;</code> symbols.</p>"},{"location":"scs/scs/#comments","title":"Comments","text":"<p>You can use C-style comments in sc.s-text: <pre><code>// one line comment\nfruit -&gt; apple;\n/* Multiline\n * comment\n */\n</code></pre></p>"},{"location":"scs/scs/#link-to-files","title":"Link to files","text":"<p>To make an <code>sc-link</code> into specified file you can use special type identifier: <pre><code>\"file://&lt;file name&gt;\"\n</code></pre></p> <ul> <li><code>\"file://&lt;file name&gt;\"</code> - is a relative path to a file. According to a file, where it used;</li> <li><code>\"file:///&lt;file_name&gt;\"</code> - is an absolute path to a file.</li> </ul>"},{"location":"scs/scs/#names","title":"Names","text":"<p>There are some tricks with object names:</p> <ul> <li><code>...</code> - is an unnamed object;</li> <li><code>_&lt;object name&gt;</code> - all object names, that starts with symbol <code>_</code> represents a variable type of objects.</li> </ul> <p>Objects identifier visibility. By default, all objects with name <code>x</code> are visible anywhere. After translating it into memory this object will have a system identifier equal to <code>x</code>. So if you use <code>x</code> in different scs files, then you designate the same object in them (would be the same element in a knowledge base).</p> <p>Sometimes you need to designate the same objects in different files, but do not generate a system identifier in memory for it. In this case you should to prefix it name with a <code>.</code> symbol. For example: <code>.x</code>.</p> <p>In case, when you need to make a named object just local for an scs file, then you should to use <code>..</code> prefix (example: <code>..x</code>).</p> <p>So a rule to build identifier is:</p> <pre><code>[visibility][variable]&lt;identifier&gt;\n</code></pre> <p>For example identifier <code>.._x</code> locally visible variable identifier.</p>"},{"location":"scs/scs/#aliases","title":"Aliases","text":"<p>You can use alias for any sc-element by using <code>=</code> operator. There are some examples:</p> <pre><code>@file_alias = \"file://...\";;\n@link_alias = [];;\n@element_alias = element_idtf;;\n@edge_alias = (c -&gt; b);;\n@alias_to_alias = @element_alias;;\n</code></pre> <p>Warning</p> <p>Aliases visible just in a file scope.  You should define alias before usage.</p> <p>Note</p> <p>SCs-code is split into levels. Each level allows to minimize number of string symbols to represent the same structures.</p>"},{"location":"scs/scs/#scs-code-level-1","title":"SCs-code level 1","text":"<p>SCs-code level 1 is a simple representation of SC-code. It represents SC-texts with just simple triples. Each triple contains <code>subject</code>, <code>predicate</code>, <code>object</code> that are split by <code>|</code> symbol. Line <code>sc_node#subject | sc_edge_access#predicate | sc_node#object;;</code> is a sentence.</p> <p>Identifier of <code>subject</code>, <code>predicate</code>, <code>object</code> build with rule:</p> <pre><code>&lt;type&gt;#&lt;identifier&gt;\n</code></pre> <p>Where <code>type</code> is an element type specification. It can be one of possible values:</p> <ul> <li><code>sc_node</code> - equal to ;</li> <li><code>sc_link</code> - equal to ;</li> <li><code>sc_edge_dcommon</code> - equal to ;</li> <li><code>sc_edge_ucommon</code> - equal to ;</li> <li><code>sc_edge_main</code> - equal to ;</li> <li><code>sc_edge_access</code> - equal to .</li> </ul> <p>Examples</p> SCg construction Equal SCs-code level 1 text <pre>\n        <code>\n// append set of apples into fruit set\nsc_node#fruit\n  | sc_edge_main#..edge \n  | sc_node#apple;;\n// append set of bananas into fruit set\nsc_node#fruit\n  | sc_edge_main#..edge\n  | sc_node#banana;;\n        </code>\n      </pre> <pre>\n        <code>\nsc_node#apple \n  | sc_edge_dcommon#..common_edge \n  | \"file://apple.png\";;\n/*append edge from nrel_image relation into\n  edge between apple set and it's image*/\nsc_node_norole_relation#nrel_image \n  | sc_edge_main#..access_edge \n  | sc_edge_dcommon#..common_edge;;\n        </code>\n      </pre> <p>SCs-code level 1 allows you to represent any kind of SC-code construction. It's a low-level representation and commonly used as a transport format, that is very simple for parsing.</p>"},{"location":"scs/scs/#scs-code-level-2","title":"SCs-code level 2","text":"<p>This level of SCs-code add two new features:</p> <ul> <li>using of extended alphabet of edges;</li> <li>using of compound identifiers of an edges.</li> </ul> <p>On this level you can make sentences by rule: <pre><code>&lt;element&gt; &lt;edge&gt; &lt;element&gt;;;\n</code></pre></p> <p>Where <code>&lt;edge&gt;</code> can be on of values:</p> SCs-code SCg-code equivalent `&lt;` or `&gt;` `&lt;&gt;` `&lt;..` or `..&gt;` `&lt;=&gt;` `_&lt;=&gt;` `&lt;=` or `=&gt;` `_&lt;=` or `_=&gt;` `&lt;-` or `-&gt;` `_&lt;-` or `_-&gt;` `&lt;|-` or `-|&gt;` `_&lt;|-` or `_-|&gt;` `&lt;/-` or `-/&gt;` `_&lt;/-` or `_-/&gt;` `&lt;~` or `~&gt;` `_&lt;~` or `_~&gt;` `&lt;|~` or `~|&gt;` `_&lt;|~` or `_~|&gt;` `&lt;/~` or `~/&gt;` `_&lt;/~` or `_~/&gt;` SCg construction Equal SCs-code level 2 text <pre>\n        <code>\nfruit -&gt; apple;;\n// backward direction\nbanana &lt;- fruit;;\n        </code>\n      </pre> <p>Compound identifier of an edge builds as a sentence in SCs-code level 2, but without <code>;;</code> separator and inside brackets <code>()</code>: <code>(&lt;element&gt; &lt;edge&gt; &lt;element&gt;)</code>. So that allows to simplify usage of an edge as a source or target of another one.</p> <p>Examples</p> SCg construction Equal SCs-code level 2 text <pre>\n        <code>\nnrel_image -&gt; (fruit =&gt; \"file://apple.png\");;\n        </code>\n      </pre> <pre>\n        <code>\nd -&gt; (c -&gt; (a -&gt; b));;\n        </code>\n      </pre> <pre>\n        <code>\n(a -&gt; b) -&gt; (c &lt;- d);;\n        </code>\n      </pre>"},{"location":"scs/scs/#scs-code-level-3","title":"SCs-code level 3","text":"<p>This level of SCs-code allows to minimize symbols to represent constructions like this one: </p> <pre><code>c -&gt; (a -&gt; b);;\n</code></pre> <p>To do that you should use sentence like this:</p> <pre><code>&lt;object&gt; &lt;edge&gt; &lt;attribute&gt;: &lt;object&gt;\n</code></pre> <p>For this example it would be like this:</p> <pre><code>a -&gt; c: b;;\n</code></pre> <p>In case, when output edge from <code>c</code> is a variable, then use <code>::</code> splitter instead of <code>:</code>:</p> <pre><code>a -&gt; c:: b;;\n</code></pre> <p>equal to:</p> <pre><code>c _-&gt; (a -&gt; b);;\n</code></pre> Note: you can use <code>:</code>, <code>::</code> just to replace <code>-&gt;</code> or <code>_-&gt;</code> edges.  <p>Examples</p> SCg construction Equal SCs-code level 3 text <pre>\n        <code>\napple =&gt; nrel_image: \"file://apple.png\";;\n        </code>\n      </pre> Note: it is possible to use any number of <code>:</code>, <code>::</code> in one sentence.        <pre>\n        <code>\na &lt;=&gt; c: d:: b;;\n        </code>\n      </pre>"},{"location":"scs/scs/#scs-code-level-4","title":"SCs-code level 4","text":"<p>This level of SCs-code allows to combine many sentences with one element into one. For that purposes used ';' symbol. So if we have some sentences like:</p> <pre><code>x -&gt; y;;\nx &lt;- z;;\nx =&gt; h: r;;\n</code></pre> <p>Then using SCs level 4 we can write them like this:</p> <pre><code>x -&gt; y;\n  &lt;- z;\n  =&gt; h: r;;\n</code></pre> <p>In other words, this level of SCs-code allows to use source element one time.</p> <p>Examples</p> SCg-code Equal SCs-code level 4 text <pre>\n        <code>\nfruit -&gt; apple;\n  -&gt; banana;;\n        </code>\n      </pre> <pre>\n        <code>\na -&gt; c: d: b;\n  -&gt; e;\n  -&gt; g: f;;\n        </code>\n      </pre>"},{"location":"scs/scs/#scs-code-level-5","title":"SCs-code level 5","text":"<p>Internal sentences added to SCs-code on this level. They are wrapped by <code>(* ... *)</code> brackets. This type of sentences allow to describe connections of an element inplace. You can place these internal sentences after <code>object</code> element in triple (<code>subject -&gt; object (* ... *);;</code>), but before <code>;;</code> separator. You can use level <code>2-4</code> sentences inside this one. But there is a just one rule: </p> <p>You doesn't need to specify start element for each sentence. Because object (for which internal sentence builds)  is going to be a subject for all internal sentences </p> <p>Look at the examples, to understand how it works:</p> SCs-code level 2-4 SCs-code level 5 Description <pre>\n        <code>\nset -&gt; attr: item;;\nitem -&gt; subitem;;\n          </code>\n        </pre> <pre>\n        <code>\nset\n  -&gt; attr: item \n    (*\n      -&gt; subitem;;\n    *);;\n        </code>\n      </pre>      This is a simple example, that allow to make an sc.s-text more readable and useful. In this case text has a sublevels, that allows     to read it faster.      <pre>\n        <code>\nset -&gt; attr: item;;\nitem -&gt; subitem;;\nitem -&gt; attr2: subitem2;;\n        </code>\n      </pre> <pre>\n        <code>\nset \n  -&gt; attr: item\n  (* \n    -&gt; subitem;;\n    -&gt; attr2:\n      subitem2;;\n  *);;\n        </code>\n      </pre>      You can use as much as you need sentences in <code>(* *)</code>, but all of them should be separated by <code>;;</code>.      <pre>\n        <code>\n@en_idtf = [sc-element];;\n@ru_idtf = [sc-\u044d\u043b\u0435\u043c\u0435\u043d\u0442];;\n@en_idtf &lt;- lang_en;;\n@ru_idtf &lt;- lang_ru;;\nsc_element \n  =&gt; nrel_main_idtf: \n    @en_idtf;\n    @ru_idtf;;\n        </code>\n      </pre> <pre>\n        <code>\nsc_element\n  =&gt; nrel_main_idtf:\n    [sc-element]\n    (* &lt;- lang_en;; *);\n  =&gt; nrel_main_idtf:\n    [sc-\u044d\u043b\u0435\u043c\u0435\u043d\u0442]\n    (* &lt;- lang_ru;; *);;\n        </code>\n      </pre>      This type of syntax is very useful, when you need to specify some meta information on <code>sc-link</code>'s.     In this example we specify two main identifiers for a <code>sc_element</code>. One is an english (<code>lang_en</code>) identifier,     another one is a russian (<code>lang_ru</code>)."},{"location":"scs/scs/#scs-code-level-6","title":"SCs-code level 6","text":"<p>There are some new complex aliases, that adds by this level of SCs-code:</p> <ul> <li><code>[...]</code> - this is a short representation of <code>sc-link</code> with a content. You can create <code>sc-link</code> with a specified content by using this feature. There are all possible cases:</li> </ul> Type Description Example `string` You can write any string that you wish inside <code>[ ... ]</code> alias <pre>\n          <code>\nx -&gt; [any string];;\nx -&gt; [this is a \n multiline text];;\n          </code>\n        </pre> `number` You can specify a number as a binary data. To do that, just use syntax:         <code>[^\"type: value\"]</code>. Where <code>type</code> is a one of possible types:         <ul> <li><code>int</code> - signed integer value (32 bit). You can also use such types for an integer:             <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code> </li> <li><code>uint</code> - unsigned integer value (32 bit). You can also use such type for an unsigned integer:             <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code> </li> <li><code>float</code> - 32-bit float value</li> <li><code>double</code> - 64-bit float value</li> </ul> <pre><code>\nx -&gt; [^\"float: 435.2346\"];;\nx -&gt; [^\"int8: 7\"];;\nx -&gt; [^\"uint: 781236\"];;\n        </code></pre> <ul> <li><code>[* ... *]</code> this is a short representation of <code>sc-structure</code>. You can use just sc.s-text inside these brackets.   So these brackets will designate an <code>sc-structure</code> (<code>sc-node</code> with a type <code>sc_node_struct</code>). All elements inside   brackets will have ingoing edge (type <code>sc_edge_main</code>) from that <code>sc-node</code>.  SCs-code level 2-5 SCs-code level 6 <pre><code>\n@edge_alias = (set -&gt; item);;\nstruct -&gt; set; item; @edge_alias;;\n        </code></pre> <pre>\n          <code>\n@struct = [* set -&gt; item;; *];;\n          </code>\n        </pre> </li> </ul> <p>That's important</p> <p>S\u0441.s-text inside <code>[* ... *]</code> has the same rules and semantic, like it will be in a separated file</p> <ul> <li><code>{ ... }</code> is a short representation of non-oriented set. This feature allow to make sets in very fast way.   Syntax looks like:</li> </ul> <pre><code>@non_oriented_set = {\n  element1;\n  attr2: element2;\n  ...\n  last_element // no semicolon after last element\n&gt;;;\n</code></pre> <ul> <li><code>&lt; ... &gt;</code> is a short representation of oriented set. This feature allow to make sets in very fast way.   Syntax looks like:</li> </ul> <pre><code>@oriented_set = &lt;\n  element1;\n  attr2: element2;\n  ...\n  last_element // no semicolon after last element\n&gt;;;\n</code></pre> SCs-code level 2-5 SCs-code level 6 Comments <pre>\n        <code>\nset\n  &lt;- sc_node_tuple;\n  -&gt; element1;\n  -&gt; attr2: element2;\n  -&gt; element3;;\n        </code>\n      </pre> <pre>\n        <code>\n@set = {\n  element1;\n  attr2: element2;\n  element3 // no semicolon\n};;\n        </code>\n      </pre> Using set looks much cleaner. You can use even attributes on it. <pre>\n        <code>\nmeta_set \n  &lt;- sc_node_tuple;\n  -&gt; set1;\n  -&gt; set2;;\n\nset1\n  &lt;- sc_node_tuple;\n  -&gt; element1;\n  -&gt; attr2: element2;\n  -&gt; element3;;\n\nset2\n  &lt;- sc_node_tuple;\n  -&gt; element5;\n  -&gt; element6;;\n\nset3\n  &lt;- sc_node_tuple;\n  -&gt; element10;;\n\nelement \n  =&gt; nrel_relation:\n    set3;;\n        </code>\n      </pre> <pre>\n        <code>\n@meta_set = {\n  {\n    element1;\n    attr2: element2;\n    element3\n  };\n  {\n    element5;\n    element6\n  }\n};;\n\nelement \n  =&gt; nrel_relation:\n  {\n    element10\n  };;\n        </code>\n      </pre> You can use set alias inside any other complex aliases and triples. <pre>\n        <code>\nset\n  &lt;- sc_node_tuple;;\n\n@first_arc \n  = (set -&gt; rrel_1: element1);;\n@second_arc \n  = (set -&gt; element2);;\n\nnrel_basic_sequence\n  -&gt; (@first_arc =&gt; @second_arc);;\n        </code>\n      </pre> <pre>\n        <code>\n@set = &lt;\n  element1;\n  element2 // no semicolon\n&gt;;;\n        </code>\n      </pre> Using set looks much cleaner. You can use even attributes on it."},{"location":"scs/scs/#keynodes","title":"Keynodes","text":"<p>There are a list of element type keynodes, that can be used to specify type of sc-element:</p> Keynode Equal sc-type Equal sc.g-element sc_node ScType::NodeConst sc_link ScType::LinkConst sc_edge_dcommon ScType::EdgeDCommonConst sc_edge_ucommon ScType::EdgeUCommonConst sc_edge_main ScType::EdgeAccessConstPosPerm sc_edge_access ScType::EdgeAccess sc_node_tuple ScType::NodeTuple sc_node_struct ScType::NodeStruct sc_node_role_relation ScType::NodeRole sc_node_norole_relation ScType::NodeNoRole sc_node_class ScType::NodeClass sc_node_material ScType::NodeMaterial <p>There are old keynodes, that used for backward compatibility:</p> Keynode Equal sc-type New keynode sc_arc_main ScType::EdgeAccessConstPosPerm sc_edge_main sc_edge ScType::EdgeUCommonConst sc_edge_ucommon sc_arc_common ScType::EdgeDCommonConst sc_edge_dcommon sc_arc_access ScType::EdgeAccess sc_edge_access sc_node_not_relation ScType::NodeConstClass sc_node_class sc_node_not_binary_tuple ScType::NodeConstTuple sc_node_tuple <p>There is an example of usage:</p> SCs-code Equal SCg-code <pre>\na &lt;- sc_node_class;;\na _-&gt; _b;;\n_b &lt;- sc_node_material;;\n      </pre> <pre>\n_x =&gt; nrel_y: t;;\nnrel_y &lt;- sc_node_norole_relation;;\n      </pre>"},{"location":"scs/scs/#frequently-asked-questions","title":"Frequently Asked Questions","text":"<ul> <li>What SCs-code level is recommended to use?</li> <li>Can I combine different levels in one SCs file?</li> </ul>"},{"location":"scs/scs/#what-scs-code-level-is-recommended-to-use","title":"What SCs-code level is recommended to use?","text":"<p>The first levels of SCs-code have minimal syntax, so it is simple to handle sc.s-text of these levels. But the last levels of SCs-code allow you to make sc.s-text more compact, but these levels of SCs-code have more complicated syntax.</p>"},{"location":"scs/scs/#can-i-combine-different-levels-in-one-scs-file","title":"Can I combine different levels in one SCs file?","text":"<p>All levels of SCs-code can be combined. Usually it is useful to use 4-6 levels if you use 2-3 levels.</p>"}]}